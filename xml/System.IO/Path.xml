<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="87efe827b4d4d649387abf9f4fc5627fccf54480" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013924" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>在含有檔案或目錄路徑資訊的 <see cref="T:System.String" /> 執行個體上執行作業。 這些作業是以跨平台方式來執行的。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 路徑會是字串，提供檔案或目錄的位置。 路徑不會不一定會指向磁碟; 上的位置例如，路徑可能會對應到記憶體中或在裝置上的位置。 確切路徑的格式取決於目前的平台。 比方說，在某些系統上，路徑可以使用啟動磁碟機或磁碟區的代號，雖然這個項目不存在於其他系統。 在某些系統中，檔案路徑可以包含延伸模組，這表示儲存在檔案中的資訊類型。 副檔名的檔案名稱的格式是平台相依;例如，某些系統限制為三個字元，延伸模組，部分則否。 目前的平台也會決定一組字元用來分隔項目路徑，以及指定路徑時，無法使用的字元集。 由於這些差異的欄位`Path`類別的某些成員的確切行為及`Path`類別具有平台相依性。  
  
 路徑可以包含絕對或相對的位置資訊。 絕對路徑完整指定的位置： 檔案或目錄可以唯一識別不論目前的位置。 相對路徑指定的部分的位置： 尋找指定的相對路徑的檔案時，將會使用做為起點的目前位置。 若要判斷目前的目錄，請呼叫<xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>。  

 .NET core 1.1 和更新版本以及.NET Framework 4.6.2 和更新版本也支援的裝置名稱，例如檔案系統物件的存取權 」\\？ \C:\"。

如需有關在 Windows 上的檔案路徑格式的詳細資訊，請參閱 <<c0> [ 在 Windows 系統上的檔案路徑格式](~/docs/standard/io/file-path-formats.md)。

 大部分成員`Path`類別不會與檔案系統互動，並且不會驗證指定的路徑字串的檔案是否存在。 `Path` 類別成員，修改路徑字串，例如<xref:System.IO.Path.ChangeExtension%2A>，檔案系統中有不會影響檔案的名稱。 `Path` 成員執行，不過，驗證指定的路徑字串的內容，則擲回<xref:System.ArgumentException>例外狀況，如果字串包含無效的路徑字串中從傳回的字元中所定義的字元<xref:System.IO.Path.GetInvalidPathChars%2A>方法。 例如，在 Windows 架構桌面平台上無效路徑字元可能會包含引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0)，並透過 18 和 20 到 25 的 Unicode 字元 16。  
  
 成員`Path`類別可讓您快速且輕鬆地執行一般的作業，例如判斷副檔名是否為組件的路徑，以及將兩個字串結合成一個路徑名稱。  
  
 所有成員`Path`類別都是靜態的而且可以因此呼叫而不需要路徑的執行個體。  
  
> [!NOTE]
>  接受的路徑做為輸入字串的成員，該路徑必須是語式正確，或引發例外狀況。 比方說，如果路徑是完整名稱，但以空格開頭，路徑不被修剪中類別的方法。 因此，路徑的格式不正確，而且會引發例外狀況。 同樣地，路徑的組合無法完整限定兩次。 例如，"c:\temp c:\windows，"也會引發例外狀況在大部分情況下。 請確定您的路徑是語式正確的當您使用接受路徑字串的方法。  
  
 在接受路徑的成員，路徑可以參考到檔案或只是一個目錄。 指定的路徑也可以參考相對路徑或通用命名慣例 (UNC) 路徑的伺服器和共用的名稱。 例如，如果以下所有狀況可接受的路徑：  
  
-   "c:\\\MyDir\\\MyFile.txt 」 以 C# 或 Visual Basic 中的 「 c:\MyDir\MyFile.txt"。  
  
-   "c:\\\MyDir 」 以 C# 或 Visual Basic 中的 「 c:\mydir\"。  
  
-   "MyDir\\\MySubdir 」 以 C# 或 Visual Basic 中的 「 MyDir\MySubDir"。  
  
-   「\\\\\\\MyServer\\\MyShare 」 在 C# 中，或 「\\\MyServer\MyShare"在 Visual Basic 中。  
  
 因為所有這些作業會在字串上執行，就無法驗證結果在所有案例中有效。 比方說，<xref:System.IO.Path.GetExtension%2A>方法會剖析字串，您將傳遞給它，並從該字串會傳回延伸模組。 不過，這不表示該副檔名的檔案存在磁碟上。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。   
  
## Examples  
 下列範例示範一些主要成員的`Path`類別。  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">HOW TO：將文字寫入檔案</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">作法：讀取和寫入新建立的資料檔案</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供平台特定替代字元，用以在反映階層式檔案系統組織的路徑字串中來分隔目錄層級。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
這個欄位可以有相同的值<xref:System.IO.Path.DirectorySeparatorChar>。 `AltDirectorySeparatorChar` 和<xref:System.IO.Path.DirectorySeparatorChar>都適用於分隔的路徑字串中的目錄層級。  
  
這個欄位的值是正斜線 （'/') 在 Windows 和 unix 作業系統上。  
  
## Examples  

下列範例會顯示<xref:System.IO.Path>欄位在 Windows 和 unix 系統上的值。 請注意 Windows 支援正斜線 (所傳回的<xref:System.IO.Path.AltDirectorySeparatorChar>欄位) 或反斜線 (所傳回的<xref:System.IO.Path.DirectorySeparatorChar>欄位) 為路徑分隔符號字元，而以 Unix 為基礎的系統則支援正斜線。

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要修改的路徑資訊。 路徑不可以包含定義於 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 的任何一個字元。</param>
        <param name="extension">新的副檔名 (可能有前置句點)。 指定 <see langword="null" /> 以從 <paramref name="path" /> 移除現有副檔名。</param>
        <summary>變更路徑字串的副檔名。</summary>
        <returns>已修改的路徑資訊。  
  
在 Windows 架構桌面平台上，如果 <paramref name="path" /> 為 <see langword="null" /> 或空字串 ("")，則會傳回未修改的路徑資訊。 如果 <paramref name="extension" /> 為 <see langword="null" />，則傳回的字串會包含已移除其副檔名的指定路徑。 如果 <paramref name="path" /> 沒有副檔名，並且 <paramref name="extension" /> 不是 <see langword="null" />，則傳回的路徑字串會包含附加至 <paramref name="path" /> 結尾的 <paramref name="extension" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有`path`也`extension`包含句點 （.）、`ChangeExtension`新增期間。  
  
 `extension`參數可以包含多個句號和任何有效的路徑字元，而且可以是任何長度。 如果`extension`已`null`，傳回的字串包含的內容`path`，最後一個期間和之後的所有字元移除。  
  
 如果`extension`為空字串，傳回的 path 字串中包含的內容`path`在最後一個句號的任何字元移除。  
  
 如果`path`沒有延伸模組並`extension`不是`null`，傳回的字串包含`path`後面`extension`。  
  
 如果`extension`不是`null`，而且不包含前置的句點，期間加入。  
  
 如果`path`包含多個句號隔開，多個延伸模組傳回的字串包含的內容`path`，最後一個期間和之後的所有字元取代`extension`。 例如，如果`path`是 「 \Dir1\examples\pathtests.csx.txt"和`extension`"cs"，修改過的路徑是 「 \Dir1\examples\pathtests.csx.cs"。  
  
 您不可能以確認傳回的結果是在所有案例中有效。 例如，如果`path`是空的`extension`附加。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範使用`ChangeExtension`方法。  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將多個字串合併為一個路徑。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

這個方法被要將個別的字串串連成單一字串，表示檔案路徑。 不過，如果第一個以外的引數包含根的路徑，會忽略任何先前的路徑元件，而且傳回的字串開頭的根的路徑元件。 做為替代`Combine`方法，請考慮使用<xref:System.IO.Path.Join%2A>或<xref:System.IO.Path.TryJoin%2A>方法。

> [!IMPORTANT]
> 這個方法會假設第一個引數是絕對路徑，以及下列的引數或引數都是相對路徑。 如果這不是如此，及尤其是在任何後續的引數都是由使用者輸入的字串，請呼叫<xref:System.IO.Path.Join%2A>或<xref:System.IO.Path.TryJoin%2A>方法改為。

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">路徑中各部分的陣列。</param>
        <summary>將一個字串陣列合併為單一路徑。</summary>
        <returns>合併的路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` 應該是路徑的要合併部分的陣列。 如果其中一個後續的路徑是絕對路徑，合併作業重設開頭的絕對路徑，並捨棄所有先前的結合的路徑。  

如果中的任何項目`paths`但最後一個不是磁碟機和結尾不是其中一個<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>字元，`Combine`方法會將<xref:System.IO.Path.DirectorySeparatorChar>該項目與下一個字元。 請注意，如果項目結尾不是適用於目標平台路徑分隔符號字元`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。 使用反斜線當做路徑分隔符號字元時，下列範例會比較 Windows 和 unix 系統上的結果。

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 長度為零的字串會省略的結合路徑。  
  
 如果有泛空白字元，不會剖析參數。  
  
 並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。 例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。 它會因此順利解譯由`Combine`方法。  
  
## Examples  
 下列範例會結合為一個路徑的字串陣列。  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">陣列中的一個字串包含在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">陣列中的一個字串為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">要合併的第一個路徑。</param>
        <param name="path2">要合併的第二個路徑。</param>
        <summary>將兩個字串合併為一個路徑。</summary>
        <returns>合併的路徑。 如果指定的其中一個路徑是長度為零的字串，這個方法會傳回其他路徑。 如果 <paramref name="path2" /> 包含絕對路徑，這個方法會傳回 <paramref name="path2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`path1`不是磁碟機參考 （也就是"C:"或"D:"） 和結尾不是有效的分隔符號字元如中所定義<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>附加至`path1`串連之前。 請注意，如果`path1`不適用於目標平台路徑分隔符號字元會停止於`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。 使用反斜線當做路徑分隔符號字元時，下列範例會比較 Windows 和 unix 系統上的結果。  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 如果`path2`不包含根 (例如，如果`path2`開頭不是分隔符號字元或指定了磁碟機)，結果是串連兩個路徑中, 介的分隔符號字元。 如果`path2`包含根，`path2`會傳回。  
  
 如果有泛空白字元，不會剖析參數。 因此，如果`path2`包含泛空白字元 (例如，"\file.txt 」)，<xref:System.IO.Path.Combine%2A>方法會附加`path2`要`path1`而不是只傳回`path2`。  
  
 並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。 例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。 它會因此順利解譯由`Combine`方法。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範如何使用`Combine`以 Windows 為基礎的桌面平台上的方法。  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> 或 <paramref name="path2" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個不正確字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> 或 <paramref name="path2" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">HOW TO：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">要合併的第一個路徑。</param>
        <param name="path2">要合併的第二個路徑。</param>
        <param name="path3">要合併的第三個路徑。</param>
        <summary>將三個字串合併為一個路徑。</summary>
        <returns>合併的路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` 應該是絕對路徑 (例如，"d:\archives 」 或 「\\\archives\public")。 如果`path2`或`path3`也會重設為該絕對路徑與合併作業捨棄所有先前的結合路徑的絕對路徑。  
  
 長度為零的字串會省略的結合路徑。  
  
 如果`path1`或是`path2`不是磁碟機參考 （也就是"C:"或"D:"） 和結尾不是有效的分隔符號字元如中所定義<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>附加至`path1`或`path2`串連之前。 請注意，如果`path1`或是`path2`不適用於目標平台路徑分隔符號字元會停止於`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。 使用反斜線當做路徑分隔符號字元時，下列範例會比較 Windows 和 unix 系統上的結果。 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 如果`path2`不包含根 (例如，如果`path2`開頭不是分隔符號字元或指定了磁碟機)，結果是串連兩個路徑中, 介的分隔符號字元。 如果`path2`包含根，`path2`會傳回。  
  
 如果有泛空白字元，不會剖析參數。 因此，如果`path2`包含泛空白字元 (例如，"\file.txt 」)，<xref:System.IO.Path.Combine%2A>方法會附加`path2`至`path1`。  
  
 並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。 例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。 它會因此順利解譯由`Combine`方法。  
  
   
  
## Examples  
 下列範例會結合三個路徑。  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 包含一或多個在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">要合併的第一個路徑。</param>
        <param name="path2">要合併的第二個路徑。</param>
        <param name="path3">要合併的第三個路徑。</param>
        <param name="path4">要合併的第四個路徑。</param>
        <summary>將四個字串合併為一個路徑。</summary>
        <returns>合併的路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` 應該是絕對路徑 (例如，"d:\archives 」 或 「\\\archives\public")。如果其中一個後續的路徑也是絕對路徑，則合併作業會捨棄所有先前合併的路徑，並重設為該絕對路徑。  
  
 長度為零的字串會省略的結合路徑。  
  
 如果`path1`， `path2`，或`path3`不是磁碟機參考 （也就是"C:"或"D:"） 和結尾不是有效的分隔符號字元如中所定義<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>會附加到其之前串連。 請注意，如果`path1`， `path2`，或`path3`不適用於目標平台路徑分隔符號字元會停止於`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。 使用反斜線當做路徑分隔符號字元時，下列範例會比較 Windows 和 unix 系統上的結果。 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 如果`path2`不包含根 (例如，如果`path2`開頭不是分隔符號字元或指定了磁碟機)，結果是串連兩個路徑中, 介的分隔符號字元。 如果`path2`包含根，`path2`會傳回。  
  
 如果有泛空白字元，不會剖析參數。 因此，如果`path2`包含泛空白字元 (例如，"\file.txt 」)，<xref:System.IO.Path.Combine%2A>方法會附加`path2`至`path1`。  
  
 並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。 例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。 它會因此順利解譯由`Combine`方法。  
  
   
  
## Examples  
 下列範例結合了四個路徑。  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 包含一或多個在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供平台特定字元，用以在反映階層式檔案系統組織的路徑字串中分隔目錄層級。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> 和`DirectorySeparatorChar`都適用於分隔的路徑字串中的目錄層級。  
  
當您使用.NET Core 開發在多個平台執行的應用程式：

- 如果您想要硬式編碼的目錄分隔符號字元，您應該使用正斜線 (`/`) 字元。 它是唯一可辨識的目錄分隔符號字元在 Unix 系統上的輸出範例所示，並為<xref:System.IO.Path.AltDirectorySeparatorChar>在 Windows 上。

- 您可以使用字串串連來動態擷取路徑分隔符號字元，在執行階段，並將其整合到檔案系統路徑。 例如，套用至物件的 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   您也可以擷取的值從<xref:System.IO.Path.AltDirectorySeparatorChar>屬性，因為它是在 Windows 和 Unx 為基礎的系統上相同。

- 擷取<xref:System.IO.Path.AltDirectorySeparatorChar>屬性

如果您的應用程式不是跨平台，您可以使用適用於您的系統的分隔符號。

## Examples  

下列範例會顯示<xref:System.IO.Path>欄位在 Windows 和 unix 系統上的值。 請注意 Windows 支援正斜線 (所傳回的<xref:System.IO.Path.AltDirectorySeparatorChar>欄位) 或反斜線 (所傳回的<xref:System.IO.Path.DirectorySeparatorChar>欄位) 為路徑分隔符號字元，而以 Unix 為基礎的系統則支援正斜線。  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">HOW TO：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>傳回指定路徑字串的目錄資訊，此路徑以字元範圍表示。</summary>
        <returns><paramref name="path" /> 的目錄資訊、或 <paramref name="path" /> 為 <see langword="null" /> 則為空的範圍、空的範圍，或根目錄 (例如 \, C: 或 \\server\share)。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">檔案或目錄的路徑。</param>
        <summary>傳回指定路徑字串的目錄資訊。</summary>
        <returns><paramref name="path" /> 的目錄資訊；如果 <paramref name="path" /> 表示根目錄或為 null，則為 <see langword="null" />。 如果 <paramref name="path" /> 不包含目錄資訊，則傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在大部分情況下，這個方法所傳回的字串所組成，但不是包括最後一個路徑中的所有字元<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>。 如果路徑包含根目錄，例如"c:\\"，則會傳回 null。 請注意，這個方法並不支援使用的路徑 」 檔案:"。 因為傳回的路徑不包含<xref:System.IO.Path.DirectorySeparatorChar>或是<xref:System.IO.Path.AltDirectorySeparatorChar>，將傳回的路徑傳遞回<xref:System.IO.Path.GetDirectoryName%2A>方法會導致每個後續的呼叫，在結果字串的一個資料夾層級的截斷。 例如，將路徑 「 C:\Directory\SubDirectory\test.txt"傳遞到<xref:System.IO.Path.GetDirectoryName%2A>方法會傳回"C:\Directory\SubDirectory 」。 將"C:\Directory\SubDirectory 」，該字串傳遞到<xref:System.IO.Path.GetDirectoryName%2A>會導致 「 C:\Directory"。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範如何使用`GetDirectoryName`以 Windows 為基礎的桌面平台上的方法。  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數包含無效字元、空白，或只包含空格。</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 <paramref name="path" /> 參數超過系統定義的長度上限。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">HOW TO：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">可取得副檔名的檔案路徑。</param>
        <summary>傳回檔案路徑的副檔名，此路徑以唯讀的字元範圍表示。</summary>
        <returns>指定路徑的副檔名 (包括句點 ".")，如果 <paramref name="path" /> 沒有副檔名資訊，則為 <see cref="P:System.ReadOnlySpan`1.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

這個方法會取得的延伸模組`path`藉由搜尋`path`時間 ("。")，從 在唯讀模式的範圍中的最後一個字元，且繼續向其第一個字元。 如果之前找到一段<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>字元，傳回的唯讀範圍包含句點，並將字元之後，否則<xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>會傳回。  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要從中取得副檔名的路徑字串。</param>
        <summary>傳回擴充功能 (包括句點"。") 的指定的路徑字串。</summary>
        <returns>指定路徑的副檔名 (包括句點 ".")、<see langword="null" /> 或 <see cref="F:System.String.Empty" />。 如果 <paramref name="path" /> 是 <see langword="null" />，則 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 會傳回 <see langword="null" />。 如果 <paramref name="path" /> 沒有副檔名資訊，則 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

這個方法會取得的延伸模組`path`藉由搜尋`path`開頭的最後一個字元的句號 （.），如`path`而繼續到第一個字元。 如果之前找到一段<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>字元，傳回的字串會包含句點，並將字元後，否則<xref:System.String.Empty?displayProperty=nameWithType>會傳回。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。
 
## Examples  
 下列範例示範如何使用`GetExtension`以 Windows 為基礎的桌面平台上的方法。  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">包含路徑的唯讀範圍，這是取得檔案名稱和副檔名的路徑。</param>
        <summary>傳回檔案路徑的檔案名稱和副檔名，此路徑以唯讀的字元範圍表示。</summary>
        <returns><paramref name="path" /> 中最後目錄分隔符號字元之後的字元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

傳回唯讀範圍包含的路徑，請依照下列中的最後一個分隔符號的字元`path`。 如果最後一個字元`path`是磁碟區或目錄分隔符號字元，則方法會傳回<xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>。 如果`path`不包含任何分隔符號字元，則方法會傳回`path`。

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要從中取得檔案名稱和副檔名的路徑字串。</param>
        <summary>傳回指定路徑字串的檔案名稱和副檔名。</summary>
        <returns><paramref name="path" /> 中最後目錄分隔符號字元之後的字元。 如果 <paramref name="path" /> 的最後一個字元是目錄或磁碟區分隔符號字元，這個方法會傳回 <see cref="F:System.String.Empty" />。 如果 <paramref name="path" /> 為 <see langword="null" />，這個方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

傳回的值是`null`的檔案路徑是否`null`。  
  
用來判斷檔案名稱開頭的分隔符號字元<xref:System.IO.Path.DirectorySeparatorChar>和<xref:System.IO.Path.AltDirectorySeparatorChar>。  

因為*\\* Unix 上是合法的檔名`GetFileName`下以 Unix 為基礎的平台執行無法正確地傳回檔案名稱，從以 Windows 為基礎的路徑，例如*c:\\mydir\\myfile.ext*，但`GetFileName`下以 Windows 為基礎的平台執行可以正確地傳回檔案名稱，從以 Unix 為基礎的路徑，例如 */tmp/myfile.ext*，因此行為`GetFileName`方法不完全是以 Unix 為基礎和以 Windows 為基礎的平台上相同。

如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範的行為`GetFileName`以 Windows 為基礎的桌面平台上的方法。  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">HOW TO：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">包含路徑的唯讀範圍，可從該路徑取得沒有副檔名的檔案名稱。</param>
        <summary>傳回檔案路徑的檔案名稱和副檔名，此路徑以唯讀的字元範圍表示。</summary>
        <returns><see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> 傳回的唯讀範圍字元，不含最後的句號 (.) 以及其後所有字元。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">檔案的路徑。</param>
        <summary>傳回沒有副檔名的指定路徑字串的檔案名稱。</summary>
        <returns><see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> 傳回的字串，但不包含最後的句號 (.) 以及其後的所有字元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會驗證路徑或檔案名稱已經存在。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範使用`GetFileNameWithoutExtension`方法。  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">要為其取得絕對路徑資訊的檔案或目錄。</param>
        <summary>傳回指定路徑字串的絕對路徑。</summary>
        <returns><paramref name="path" /> 的完整位置，例如 "C:\MyFile.txt"。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 絕對路徑包括尋找檔案或目錄的系統上所需的所有資訊。  
  
 指定檔案或目錄的`path`不一定要存在。 例如，如果*c:\temp\newdir*是目前的目錄中，呼叫`GetFullPath`檔案名稱，例如*test.txt*傳回*c:\temp\newdir\test.txt*。 檔案必須存在。  

> [!IMPORTANT]
> 如果`path`是相對路徑，這個多載會傳回可以根據目前的磁碟機和目前的目錄的完整的路徑。 當應用程式執行時，可以會隨時變更目前磁碟機和目前的目錄。 如此一來，無法事先判斷這個多載所傳回的路徑。 若要傳回具有決定性的路徑，請呼叫<xref:System.IO.Path.GetFullPath(System.String,System.String)>多載。 您也可以呼叫<xref:System.IO.Path.IsPathFullyQualified%2A>方法，以判斷是否路徑完整或相對路徑，因此是否呼叫`GetFullPath`必不可少。

 不過，如果`path`存在，呼叫端必須具有權限，來取得路徑資訊`path`。 請注意，不同於大部分成員<xref:System.IO.Path>類別，這個方法會存取檔案系統。  
  
 這個方法會使用目前的目錄及磁碟區上的最新資訊來完整限定`path`。 如果您指定的檔案只能在命名`path`，`GetFullPath`傳回目前目錄的完整的路徑。  
  
 如果您傳入短檔名時，會將它擴展為長檔名。  
  
 如果路徑不包含任何有效字元數，它無效，除非它包含一或多個"。"字元後面接著任何數目的空格;然後它會剖析為 」。 「 或 」...」。  

.NET core 1.1 和更新版本以及.NET Framework 4.6.2 和更新版本也支援路徑，包括裝置名稱，例如"\\？ \C:\"。

如需有關在 Windows 上的檔案路徑格式的詳細資訊，請參閱 <<c0> [ 在 Windows 系統上的檔案路徑格式](~/docs/standard/io/file-path-formats.md)。 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。
  
## Examples  
 下列範例示範`GetFullPath`以 Windows 為基礎的桌面平台上的方法。  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 是長度為零的字串、只包含空白字元，或包含在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。  
  
-或- 
系統可能不會擷取絕對路徑。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 含有不屬於磁碟區識別碼 (例如 "c:\\") 一部分的冒號 (":")。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑。</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">HOW TO：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">串連成 <paramref name="basePath" /> 的相對路徑。</param>
        <param name="basePath">完整路徑的開頭。</param>
        <summary>從完整的基底路徑和相對路徑傳回絕對路徑。</summary>
        <returns>絕對路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

如果`path`是空的路徑，此方法會傳回`basePath`。 如果`path`是完整的路徑，方法傳遞`path`到<xref:System.IO.Path.GetFullPath(System.String)>方法，並傳回結果。

使用此方法來傳回具決定性的路徑會根據指定的磁碟區和根目錄的目錄，當您使用相對路徑。 使用預先定義`basePath`而不是目前的磁碟機目錄可防範因非預期的變更，在目前的磁碟機和目錄的不必要的檔案路徑為基礎。 

## <a name="example"></a>範例

下列範例會定義一個變數， `basePath`，以代表應用程式的目前的目錄。 它接著將它傳遞給`GetFullPath`方法來取得應用程式的資料目錄的完整的路徑。

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 或 <paramref name="basePath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> 不是完整路徑。

-或-

<paramref name="path" /> 或 <paramref name="basePath" /> 包含無效的路徑字元，例如 U+0000。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得陣列，該陣列包含檔案名稱中不允許的字元。</summary>
        <returns>陣列，該陣列包含檔案名稱中不允許的字元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不保證此方法傳回的陣列包含一組完整的檔案和目錄名稱中無效的字元。 完整的 無效的字元可能會因檔案系統。 例如，在 Windows 架構桌面平台上無效路徑字元可能會包括 ASCII/Unicode 字元 1 到 31，以及加上引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0) 和定位字元 (\t)。  
  
   
  
## Examples  
 下列範例示範<xref:System.IO.Path.GetInvalidFileNameChars%2A>方法和<xref:System.IO.Path.GetInvalidPathChars%2A>方法來擷取無效的字元。  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得陣列，該陣列包含路徑名稱中不允許的字元。</summary>
        <returns>陣列，該陣列包含路徑名稱中不允許的字元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不保證此方法傳回的陣列包含一組完整的檔案和目錄名稱中無效的字元。 完整的 無效的字元可能會因檔案系統。 例如，在 Windows 架構桌面平台上無效路徑字元可能會包括 ASCII/Unicode 字元 1 到 31，以及加上引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0) 和定位字元 (\t)。  
  
   
  
## Examples  
 下列範例示範<xref:System.IO.Path.GetInvalidFileNameChars%2A>方法和<xref:System.IO.Path.GetInvalidPathChars%2A>方法來擷取無效的字元。  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">要從中取得根目錄資訊的路徑。</param>
        <summary>從所指定字元範圍中包含的路徑取得根目錄資訊。</summary>
        <returns>包含 `path` 之根目錄的字元範圍。</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要從中取得根目錄資訊的路徑。</param>
        <summary>取得指定路徑的根目錄資訊。</summary>
        <returns><paramref name="path" /> 的根目錄，或如果 <paramref name="path" /> 為 <see langword="null" />，則為 <see langword="null" />，或如果 <paramref name="path" /> 不包含根目錄資訊，則為空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會驗證路徑或檔案名稱已經存在。  
  
 可能的模式，這個方法所傳回的字串如下所示：  
  
- 空字串 (`path`目前磁碟機或磁碟區上所指定的相對路徑)。  
  
- 「\" (`path`目前的磁碟機上指定的絕對路徑)。  
  
- "X"(`path`指定為相對路徑上的磁碟機，其中 X 代表磁碟機或磁碟區代號)。  
  
- "X:\" (`path`指定磁碟機上指定的絕對路徑)。  
  
- "\\\ComputerName\SharedFolder" (a UNC path).  
  
- 「\\？ \C: 」 （DOS 裝置路徑，在.NET Core 1.1 和更新版本和.NET Framework 4.6.2 和更新版本支援）
   
 如需有關在 Windows 上的檔案路徑的詳細資訊，請參閱 <<c0> [ 在 Windows 系統上的檔案路徑格式](~/docs/standard/io/file-path-formats.md)。 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
## Examples  
 下列範例示範使用`GetPathRoot`方法。  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。  
  
-或- 
 已將 <see cref="F:System.String.Empty" /> 傳遞給 <paramref name="path" />。</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">HOW TO：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回隨機資料夾名稱或檔案名稱。</summary>
        <returns>隨機資料夾名稱或檔案名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.GetRandomFileName%2A>方法會傳回可用來當做資料夾名稱或檔案名稱的密碼編譯方面強式的隨機字串。 不同於<xref:System.IO.Path.GetTempFileName%2A>，<xref:System.IO.Path.GetRandomFileName%2A>不會建立檔案。 而不是最重要的檔案系統的安全性時，應該使用這個方法<xref:System.IO.Path.GetTempFileName%2A>。  
  
   
  
## Examples  
 下列範例顯示輸出來源<xref:System.IO.Path.GetRandomFileName%2A>方法。  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">應與結果相對的來源路徑。 此路徑一律視為目錄。</param>
        <param name="path">目的地路徑。</param>
        <summary>傳回某個路徑到另一個路徑的相對路徑。</summary>
        <returns>如果路徑不共用相同的根目錄，則為相對路徑或 <paramref name="path" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

路徑會解析藉由呼叫<xref:System.IO.Path.GetFullPath%2A>方法，然後再計算的差異。 方法會使用預設的檔案路徑比較目前的平台 (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>適用於 Windows 和 MacOs，<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>適用於 Linux。 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> 或 <paramref name="path" /> 為 <see langword="null" />。</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在磁碟上建立具名之零位元組的唯一暫存檔案，然後傳回該檔案的完整路徑。</summary>
        <returns>暫存檔案的完整路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立暫存檔案。TMP 檔案的副檔名。 暫存的檔案會建立在使用者的暫存資料夾中，也就是路徑傳回<xref:System.IO.Path.GetTempPath%2A>方法。  
  
 <xref:System.IO.Path.GetTempFileName%2A>方法會引發<xref:System.IO.IOException>如果它用來建立超過 65535 的檔案，而不會刪除先前的暫存檔案。  
  
 <xref:System.IO.Path.GetTempFileName%2A>方法會引發<xref:System.IO.IOException>沒有唯一暫存檔案名稱是否可用。 若要解決這個錯誤，刪除所有不必要的暫存檔案。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如沒有可用的唯一暫存檔案名稱。  
  
-或- 
這個方法無法建立暫存檔案。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入到暫存目錄。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">HOW TO：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前使用者的暫存資料夾路徑。</summary>
        <returns>暫存資料夾的路徑，結尾是反斜線。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會檢查存在的環境變數，以下列順序，並使用找到的第一個路徑：  
  
1.  TMP 環境變數所指定的路徑。  
  
2.  TEMP 環境變數所指定的路徑。  
  
3.  USERPROFILE 環境變數所指定的路徑。  
  
4.  Windows 目錄中。  
  
   
  
## Examples  
 下列程式碼將示範如何呼叫 <xref:System.IO.Path.GetTempPath%2A> 方法。  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 此範例會產生類似下列的輸出。  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">不受限制存取環境變數。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">要在其中搜尋副檔名的路徑。</param>
        <summary>判斷指定字元範圍所表示的路徑是否包含副檔名。</summary>
        <returns>如果路徑中接在最後一個目錄分隔符號字元或磁碟區分隔符號之後的字元包含句號 (".")，且後面接著一或多個字元，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

在 結尾的句點`path`不是延伸模組。

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要在其中搜尋副檔名的路徑。</param>
        <summary>判斷路徑是否包括副檔名。</summary>
        <returns>如果路徑中接在最後一個目錄分隔符號 (\\\ 或 /) 或磁碟區分隔符號 (:) 之後的字元包含句號 (.)，且後面接著一或多個字元，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從結尾開始`path`，這個方法會搜尋後面至少一個字元的句號 （.）。 如果此模式之前找到<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>遇到字元，則這個方法會傳回`true`。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範 `HasExtension` 方法的用法。  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供字元的平台特定陣列，這些字元不可以在傳遞給 <see cref="T:System.IO.Path" /> 類別成員的路徑字串引數中指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不保證此方法傳回的陣列包含一組完整的檔案和目錄名稱中無效的字元。 完整的 無效的字元可能會因檔案系統。 例如，在 Windows 架構桌面平台上無效路徑字元可能會包括 ASCII/Unicode 字元 1 到 31，以及加上引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0) 和定位字元 (\t)。  
  
> [!CAUTION]
>  請勿使用<xref:System.IO.Path.InvalidPathChars>如果您認為您的程式碼可能會執行相同的應用程式定義域，即不受信任的程式碼中。 <xref:System.IO.Path.InvalidPathChars> 是陣列，所以其項目將會覆寫。 如果不受信任的程式碼會覆寫的項目<xref:System.IO.Path.InvalidPathChars>，它可能會導致您的程式碼，可能會遭到使用者的方式運作不正常。  
  
   
  
## Examples  
 下列範例示範如何使用`InvalidPathChars`屬性。  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>傳回值，指出檔案路徑是否為完整路徑。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

多載`IsPathFullyQualified`同時使用的方法控制代碼路徑<xref:System.IO.Path.DirectorySeparatorChar>而<xref:System.IO.Path.AltDirectorySeparatorChar>字元。 它不會做為引數傳遞給它的路徑上執行任何驗證。 如此一來，Uri 會解譯為相對路徑，並傳回`false`。 

沒有差異的完整路徑 (如所示`IsPathFullyQualified`方法) 和根的路徑 (如所示<xref:System.IO.Path.IsPathRooted%2A>方法)。 A*完整的路徑*或是*絕對路徑*一律定義確切路徑從特定的磁碟機或裝置的目標檔案或目錄，並不相依於目前的磁碟機或目前的目錄。 例如，在 Windows 系統上*C:/users/user1/documents/reports/2019/january/highlights.pdf*定義目標檔案中，從 c： 磁碟機的根目錄的絕對路徑*highlights.pdf*。 A*根的路徑*指定起始磁碟機或根目錄，但取決於目前的目錄 （如果它已進行 root 破解，所指定的磁碟機） 或目前的磁碟機 （如果它已進行 root 破解的根目錄）。 下列範例說明完整的路徑與根目錄的路徑之間的差異。

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">檔案路徑。</param>
        <summary>傳回值，指出指定字元範圍所表示的檔案路徑是否固定在特定的磁碟機或 UNC 路徑。</summary>
        <returns>如果路徑固定在特定的磁碟機或 UNC 路徑，則為 <see langword="true" />；如果路徑相對於目前的磁碟機或工作目錄，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">檔案路徑。</param>
        <summary>傳回值，指出指定的檔案路徑是否固定在特定磁碟機或 UNC 路徑。</summary>
        <returns>如果路徑固定在特定的磁碟機或 UNC 路徑，則為 <see langword="true" />；如果路徑相對於目前的磁碟機或工作目錄，則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>傳回值，指出檔案路徑是否包含根目錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

A**根的路徑**是檔案路徑，會固定為特定磁碟機或 UNIC 路徑; 它有別於目前的磁碟機或工作目錄的相對路徑。 比方說，在 Windows 系統上根的路徑則會使用反斜線 (比方說，「 \Documents") 或磁碟機代號和冒號 (例如，"C:Documents 」) 開始。 

請注意，根的路徑可以 （也就，完整名稱） 的絕對或相對。 絕對的根的路徑是從磁碟機根目錄到特定的目錄完整的路徑。 相對的根的路徑指定磁碟機，但其完整的路徑會解析對目前的目錄。 下列範例會說明其間的差異。

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">要測試的路徑。</param>
        <summary>傳回值，指出所指定字元範圍所表示的檔案路徑是否包含根目錄。</summary>
        <returns>如果 <paramref name="path" /> 包含根目錄，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要測試的路徑。</param>
        <summary>傳回值，指出指定的路徑字串是否包含根目錄。</summary>
        <returns>如果 <paramref name="path" /> 包含根目錄，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.IsPathRooted%2A>方法會傳回`true`如果第一個字元是目錄分隔符號字元如 「\\"，或如果路徑的開頭的磁碟機代號和冒號 （:）。 比方說，它會傳回`true`for`path`這類字串 」\\\MyDir\\\MyFile.txt"，"c:\\\MyDir"，或 「 C:MyDir"。 它會傳回`false`針對`path`"MyDir"等字串。  
  
 這個方法不會驗證路徑或檔案名稱已經存在。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  

## Examples  
 下列範例示範如何`IsPathRooted`方法可用來測試三個字串。  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">包含第一個聯結路徑的字元範圍。</param>
        <param name="path2">包含第二個聯結路徑的字元範圍。</param>
        <summary>將兩個路徑元件串連成單一路徑。</summary>
        <returns>合併的路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
這個方法只是串連`path`並`path2`並新增兩個路徑元件之間的目錄分隔符號字元，如果尚未存在的結尾`path1`處或開端`path2`。 如果<xref:System.ReadOnlySpan%601.Length>任一`path1`或`path2`為零，則方法會傳回其他路徑。 如果<xref:System.ReadOnlySpan%601.Length>兩者`path1`並`path2`為零，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。 

如果`path1`不適用於目標平台路徑分隔符號字元會停止於`Join`方法會保留原始的路徑分隔符號字元，並將附加支援。 使用 Windows 反斜線的硬式編碼路徑中就會發生此問題 (「\") 無法辨識以 Unix 為基礎的系統做為路徑分隔符號的字元。 若要解決此問題，您可以：

- 擷取值的<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，而不是硬式編碼是目錄分隔符號字元。

- 您可以使用正斜線 （"/"） 作為目錄分隔符號字元。 此字元由<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，以 Unix 為基礎的系統上並由<xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>Windows 系統上的屬性。 

不同於<xref:System.IO.Path.Combine%2A>方法，<xref:System.IO.Path.Join%2A>方法並不會嘗試傳回的路徑的根目錄。 (亦即，如果`path2`是絕對路徑，`Join`方法不會捨棄`path1`，並傳回`path2`做為<xref:System.IO.Path.Combine%2A>方法會執行。)下列範例說明兩個方法所傳回之路徑的差異。 如果來源的`path2`是使用者輸入<xref:System.IO.Path.Combine%2A>方法可讓使用者存取檔案系統資源 (例如*c: / 使用者/User1/文件/財務/* 在此範例的情況下) 的應用程式不想要讓可供存取。  

並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Join`方法，因為您可以使用這些字元搜尋萬用字元。 例如，當`Path.Join("c:\\", "*.txt")`可能會不正確時建立檔案，它是有效的搜尋字串。 `Join`方法因此成功地將它解譯。 

## <a name="example"></a>範例

下列範例說明在所傳回的路徑中的差異<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType>和<xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType>方法。 當第一個字串是包含磁碟機和根目錄的目錄完整的路徑和第二個是從第一個路徑的相對路徑時，這兩個方法會產生相同的結果。 在第二個和第三個呼叫`ShowPathInformation`方法，這兩個方法所傳回的字串會分離開來。 在第二個方法呼叫中，第一個字串引數是磁碟機，而第二個是根目錄的目錄。 `Join`方法串連兩個字串，並且保留重複的路徑分隔符號。 `Combine`方法放棄磁碟機，並傳回目前的磁碟機的根目錄的目錄。 如果應用程式的目前磁碟機是 C:\字串用來存取檔案或目錄中的檔案，它會存取而不是 d: c:。 最後，因為第三個呼叫中的兩個引數`ShowPathInformation`的根目錄`Join`方法只是將它們附加若要建立無意義的檔案路徑，而`Combine`方法就會捨棄第一個字串，並傳回第二個。 使用此字串的檔案存取可以讓應用程式非預期的存取機密的檔案。  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">包含第一個聯結路徑的字元範圍。</param>
        <param name="path2">包含第二個聯結路徑的字元範圍。</param>
        <param name="path3">包含第三個聯結路徑的字元範圍。</param>
        <summary>將三個路徑元件串連成單一路徑。</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
這個方法只是串連`path`， `path2`，和`path3`並新增任何路徑元件之間的目錄分隔符號字元，如果尚未存在。 如果<xref:System.ReadOnlySpan%601.Length>任一`path1`， `path2`，或`path3`引數為零，則方法會串連其餘引數。 如果<xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType>的所有元件為零，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。    

如果`path1`或是`path2`不適用於目標平台路徑分隔符號字元結尾`Join`方法會保留原始的路徑分隔符號字元，並將附加支援。 使用 Windows 反斜線的硬式編碼路徑中就會發生此問題 (「\") 無法辨識以 Unix 為基礎的系統做為路徑分隔符號的字元。 若要解決此問題，您可以：

- 擷取值的<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，而不是硬式編碼是目錄分隔符號字元。

- 您可以使用正斜線 （"/"） 作為目錄分隔符號字元。 此字元由<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，以 Unix 為基礎的系統上並由<xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>Windows 系統上的屬性。 

不同於<xref:System.IO.Path.Combine%2A>方法，<xref:System.IO.Path.Join%2A>方法並不會嘗試傳回的路徑的根目錄。 (亦即，如果`path2`或是`path2`是絕對路徑，`Join`方法不會捨棄先前的路徑為<xref:System.IO.Path.Combine%2A>方法會執行。  
  
並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Join`方法，因為您可以使用這些字元搜尋萬用字元。 例如，當`Path.Join("c:\\", "temp", "*.txt")`可能會不正確時建立檔案，它是有效的搜尋字串。 `Join`方法因此成功地將它解譯。 

## <a name="example"></a>範例

下列範例說明在所傳回的路徑中的差異<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType>和<xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType>方法。 當第一個字串是包含磁碟機和根目錄的目錄完整的路徑和第二個是從第一個路徑的相對路徑時，這兩個方法會產生相同的結果。 在第二個和第三個呼叫`ShowPathInformation`方法，這兩個方法所傳回的字串會分離開來。 在第二個方法呼叫中，第一個字串引數是磁碟機，而第二個是根目錄的目錄。 `Join`方法串連兩個字串，並且保留重複的路徑分隔符號。 呼叫<xref:System.IO.Path.GetFullPath%2A>方法會排除重複項目。 `Combine`方法放棄磁碟機，並傳回目前的磁碟機的根目錄的目錄。 如果應用程式的目前磁碟機是 C:\字串用來存取檔案或目錄中的檔案，它會存取而不是 d: c:。 最後，因為第三個呼叫中的最後一個引數`ShowPathInformation`已進行 root 破解，`Join`方法只會將其附加的前兩個引數來建立無意義的檔案路徑，而`Combine`方法會捨棄的前兩個字串，並傳回第三個。 使用此字串的檔案存取可以讓應用程式非預期的存取機密的檔案。  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>平台特定分隔符號字元，用來分隔環境變數中的路徑字串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 架構桌面平台上，這個欄位的值是分號 （;） 根據預設，但其他平台上可能會有所不同。  
  
   
  
## Examples  
 下列範例示範如何使用`PathSeparator`欄位。  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">作法：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>嘗試將個別路徑元件串連成預先配置的字元範圍，然後傳回值，指出作業是否成功。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

目的地字元範圍必須足以容納串連的路徑。 接著您可以藉由呼叫擷取串連的路徑<xref:System.Span%601.Slice%2A?displayProperty=nameWithType>方法，如下列範例會示範。

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">包含第一個聯結路徑的字元範圍。</param>
        <param name="path2">包含第二個聯結路徑的字元範圍。</param>
        <param name="destination">保留串連路徑的字元範圍。</param>
        <param name="charsWritten">當方法傳回值時，該值會指出寫入 <paramref name="destination" /> 的字元數目。</param>
        <summary>嘗試將兩個路徑元件串連成單一預先配置的字元範圍，然後傳回值，指出作業是否成功。</summary>
        <returns>如果串連作業成功，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` 必須足以容納串連的路徑。 接著您可以藉由呼叫擷取串連的路徑<xref:System.Span%601.Slice%2A?displayProperty=nameWithType>方法，為此範例說明。

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">包含第一個聯結路徑的字元範圍。</param>
        <param name="path2">包含第二個聯結路徑的字元範圍。</param>
        <param name="path3">包含第三個聯結路徑的字元範圍。</param>
        <param name="destination">保留串連路徑的字元範圍。</param>
        <param name="charsWritten">當方法傳回值時，該值會指出寫入 <paramref name="destination" /> 的字元數目。</param>
        <summary>嘗試將兩個路徑元件串連成單一預先配置的字元範圍，然後傳回值，指出作業是否成功。</summary>
        <returns>如果串連作業成功，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` 必須足以容納串連的路徑。 接著您可以藉由呼叫擷取串連的路徑<xref:System.Span%601.Slice%2A?displayProperty=nameWithType>方法，為此範例說明。

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 系統上的檔案路徑格式</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供平台特定磁碟區分隔符號字元。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個欄位的值是冒號 （:） 在 Windows 和 Macintosh 上，與 UNIX 作業系統上的斜線 （/）。 這是最適合用來剖析路徑，例如"c:\windows"或 「 MacVolume:System 資料夾 」。  
  
   
  
## Examples  
 下列範例示範如何使用`VolumeSeparatorChar`欄位。  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">HOW TO：讀取檔案中的文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">作法：將文字寫入檔案</related>
      </Docs>
    </Member>
  </Members>
</Type>