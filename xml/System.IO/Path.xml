<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="87efe827b4d4d649387abf9f4fc5627fccf54480" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013924" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c2c50-101">在含有檔案或目錄路徑資訊的 <see cref="T:System.String" /> 執行個體上執行作業。</span><span class="sxs-lookup"><span data-stu-id="c2c50-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="c2c50-102">這些作業是以跨平台方式來執行的。</span><span class="sxs-lookup"><span data-stu-id="c2c50-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="c2c50-103">路徑會是字串，提供檔案或目錄的位置。</span><span class="sxs-lookup"><span data-stu-id="c2c50-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="c2c50-104">路徑不會不一定會指向磁碟; 上的位置例如，路徑可能會對應到記憶體中或在裝置上的位置。</span><span class="sxs-lookup"><span data-stu-id="c2c50-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="c2c50-105">確切路徑的格式取決於目前的平台。</span><span class="sxs-lookup"><span data-stu-id="c2c50-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="c2c50-106">比方說，在某些系統上，路徑可以使用啟動磁碟機或磁碟區的代號，雖然這個項目不存在於其他系統。</span><span class="sxs-lookup"><span data-stu-id="c2c50-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="c2c50-107">在某些系統中，檔案路徑可以包含延伸模組，這表示儲存在檔案中的資訊類型。</span><span class="sxs-lookup"><span data-stu-id="c2c50-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="c2c50-108">副檔名的檔案名稱的格式是平台相依;例如，某些系統限制為三個字元，延伸模組，部分則否。</span><span class="sxs-lookup"><span data-stu-id="c2c50-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="c2c50-109">目前的平台也會決定一組字元用來分隔項目路徑，以及指定路徑時，無法使用的字元集。</span><span class="sxs-lookup"><span data-stu-id="c2c50-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="c2c50-110">由於這些差異的欄位`Path`類別的某些成員的確切行為及`Path`類別具有平台相依性。</span><span class="sxs-lookup"><span data-stu-id="c2c50-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="c2c50-111">路徑可以包含絕對或相對的位置資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="c2c50-112">絕對路徑完整指定的位置： 檔案或目錄可以唯一識別不論目前的位置。</span><span class="sxs-lookup"><span data-stu-id="c2c50-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="c2c50-113">相對路徑指定的部分的位置： 尋找指定的相對路徑的檔案時，將會使用做為起點的目前位置。</span><span class="sxs-lookup"><span data-stu-id="c2c50-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="c2c50-114">若要判斷目前的目錄，請呼叫<xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="c2c50-115">.NET core 1.1 和更新版本以及.NET Framework 4.6.2 和更新版本也支援的裝置名稱，例如檔案系統物件的存取權 」\\？ \C:\"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="c2c50-116">如需有關在 Windows 上的檔案路徑格式的詳細資訊，請參閱 <<c0> [ 在 Windows 系統上的檔案路徑格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="c2c50-117">大部分成員`Path`類別不會與檔案系統互動，並且不會驗證指定的路徑字串的檔案是否存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="c2c50-118">`Path` 類別成員，修改路徑字串，例如<xref:System.IO.Path.ChangeExtension%2A>，檔案系統中有不會影響檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="c2c50-119">`Path` 成員執行，不過，驗證指定的路徑字串的內容，則擲回<xref:System.ArgumentException>例外狀況，如果字串包含無效的路徑字串中從傳回的字元中所定義的字元<xref:System.IO.Path.GetInvalidPathChars%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="c2c50-120">例如，在 Windows 架構桌面平台上無效路徑字元可能會包含引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0)，並透過 18 和 20 到 25 的 Unicode 字元 16。</span><span class="sxs-lookup"><span data-stu-id="c2c50-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="c2c50-121">成員`Path`類別可讓您快速且輕鬆地執行一般的作業，例如判斷副檔名是否為組件的路徑，以及將兩個字串結合成一個路徑名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="c2c50-122">所有成員`Path`類別都是靜態的而且可以因此呼叫而不需要路徑的執行個體。</span><span class="sxs-lookup"><span data-stu-id="c2c50-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2c50-123">接受的路徑做為輸入字串的成員，該路徑必須是語式正確，或引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c2c50-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="c2c50-124">比方說，如果路徑是完整名稱，但以空格開頭，路徑不被修剪中類別的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="c2c50-125">因此，路徑的格式不正確，而且會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c2c50-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="c2c50-126">同樣地，路徑的組合無法完整限定兩次。</span><span class="sxs-lookup"><span data-stu-id="c2c50-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="c2c50-127">例如，"c:\temp c:\windows，"也會引發例外狀況在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="c2c50-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="c2c50-128">請確定您的路徑是語式正確的當您使用接受路徑字串的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="c2c50-129">在接受路徑的成員，路徑可以參考到檔案或只是一個目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="c2c50-130">指定的路徑也可以參考相對路徑或通用命名慣例 (UNC) 路徑的伺服器和共用的名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="c2c50-131">例如，如果以下所有狀況可接受的路徑：</span><span class="sxs-lookup"><span data-stu-id="c2c50-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="c2c50-132">"c:\\\MyDir\\\MyFile.txt 」 以 C# 或 Visual Basic 中的 「 c:\MyDir\MyFile.txt"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="c2c50-133">"c:\\\MyDir 」 以 C# 或 Visual Basic 中的 「 c:\mydir\"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="c2c50-134">"MyDir\\\MySubdir 」 以 C# 或 Visual Basic 中的 「 MyDir\MySubDir"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="c2c50-135">「\\\\\\\MyServer\\\MyShare 」 在 C# 中，或 「\\\MyServer\MyShare"在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="c2c50-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="c2c50-136">因為所有這些作業會在字串上執行，就無法驗證結果在所有案例中有效。</span><span class="sxs-lookup"><span data-stu-id="c2c50-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="c2c50-137">比方說，<xref:System.IO.Path.GetExtension%2A>方法會剖析字串，您將傳遞給它，並從該字串會傳回延伸模組。</span><span class="sxs-lookup"><span data-stu-id="c2c50-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="c2c50-138">不過，這不表示該副檔名的檔案存在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="c2c50-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="c2c50-139">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="c2c50-140">下列範例示範一些主要成員的`Path`類別。</span><span class="sxs-lookup"><span data-stu-id="c2c50-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-141">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-142">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-143">HOW TO：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="c2c50-144">作法：讀取和寫入新建立的資料檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-145">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2c50-146">提供平台特定替代字元，用以在反映階層式檔案系統組織的路徑字串中來分隔目錄層級。</span><span class="sxs-lookup"><span data-stu-id="c2c50-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="c2c50-147">這個欄位可以有相同的值<xref:System.IO.Path.DirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="c2c50-148">`AltDirectorySeparatorChar` 和<xref:System.IO.Path.DirectorySeparatorChar>都適用於分隔的路徑字串中的目錄層級。</span><span class="sxs-lookup"><span data-stu-id="c2c50-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="c2c50-149">這個欄位的值是正斜線 （'/') 在 Windows 和 unix 作業系統上。</span><span class="sxs-lookup"><span data-stu-id="c2c50-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="c2c50-150">下列範例會顯示<xref:System.IO.Path>欄位在 Windows 和 unix 系統上的值。</span><span class="sxs-lookup"><span data-stu-id="c2c50-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="c2c50-151">請注意 Windows 支援正斜線 (所傳回的<xref:System.IO.Path.AltDirectorySeparatorChar>欄位) 或反斜線 (所傳回的<xref:System.IO.Path.DirectorySeparatorChar>欄位) 為路徑分隔符號字元，而以 Unix 為基礎的系統則支援正斜線。</span><span class="sxs-lookup"><span data-stu-id="c2c50-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-152">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-153">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-154">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-155">要修改的路徑資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-155">The path information to modify.</span></span> <span data-ttu-id="c2c50-156">路徑不可以包含定義於 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 的任何一個字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="c2c50-157">新的副檔名 (可能有前置句點)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="c2c50-158">指定 <see langword="null" /> 以從 <paramref name="path" /> 移除現有副檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="c2c50-159">變更路徑字串的副檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="c2c50-160">已修改的路徑資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-160">The modified path information.</span></span>  
  
<span data-ttu-id="c2c50-161">在 Windows 架構桌面平台上，如果 <paramref name="path" /> 為 <see langword="null" /> 或空字串 ("")，則會傳回未修改的路徑資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="c2c50-162">如果 <paramref name="extension" /> 為 <see langword="null" />，則傳回的字串會包含已移除其副檔名的指定路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="c2c50-163">如果 <paramref name="path" /> 沒有副檔名，並且 <paramref name="extension" /> 不是 <see langword="null" />，則傳回的路徑字串會包含附加至 <paramref name="path" /> 結尾的 <paramref name="extension" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-164">如果沒有`path`也`extension`包含句點 （.）、`ChangeExtension`新增期間。</span><span class="sxs-lookup"><span data-stu-id="c2c50-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="c2c50-165">`extension`參數可以包含多個句號和任何有效的路徑字元，而且可以是任何長度。</span><span class="sxs-lookup"><span data-stu-id="c2c50-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="c2c50-166">如果`extension`已`null`，傳回的字串包含的內容`path`，最後一個期間和之後的所有字元移除。</span><span class="sxs-lookup"><span data-stu-id="c2c50-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="c2c50-167">如果`extension`為空字串，傳回的 path 字串中包含的內容`path`在最後一個句號的任何字元移除。</span><span class="sxs-lookup"><span data-stu-id="c2c50-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="c2c50-168">如果`path`沒有延伸模組並`extension`不是`null`，傳回的字串包含`path`後面`extension`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="c2c50-169">如果`extension`不是`null`，而且不包含前置的句點，期間加入。</span><span class="sxs-lookup"><span data-stu-id="c2c50-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="c2c50-170">如果`path`包含多個句號隔開，多個延伸模組傳回的字串包含的內容`path`，最後一個期間和之後的所有字元取代`extension`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="c2c50-171">例如，如果`path`是 「 \Dir1\examples\pathtests.csx.txt"和`extension`"cs"，修改過的路徑是 「 \Dir1\examples\pathtests.csx.cs"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="c2c50-172">您不可能以確認傳回的結果是在所有案例中有效。</span><span class="sxs-lookup"><span data-stu-id="c2c50-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="c2c50-173">例如，如果`path`是空的`extension`附加。</span><span class="sxs-lookup"><span data-stu-id="c2c50-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="c2c50-174">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-175">下列範例示範使用`ChangeExtension`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-176"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-177">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-178">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-179">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-180">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2c50-181">將多個字串合併為一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="c2c50-182">這個方法被要將個別的字串串連成單一字串，表示檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="c2c50-183">不過，如果第一個以外的引數包含根的路徑，會忽略任何先前的路徑元件，而且傳回的字串開頭的根的路徑元件。</span><span class="sxs-lookup"><span data-stu-id="c2c50-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="c2c50-184">做為替代`Combine`方法，請考慮使用<xref:System.IO.Path.Join%2A>或<xref:System.IO.Path.TryJoin%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c2c50-185">這個方法會假設第一個引數是絕對路徑，以及下列的引數或引數都是相對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="c2c50-186">如果這不是如此，及尤其是在任何後續的引數都是由使用者輸入的字串，請呼叫<xref:System.IO.Path.Join%2A>或<xref:System.IO.Path.TryJoin%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="c2c50-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="c2c50-187">路徑中各部分的陣列。</span><span class="sxs-lookup"><span data-stu-id="c2c50-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="c2c50-188">將一個字串陣列合併為單一路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-189">合併的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="c2c50-190">`paths` 應該是路徑的要合併部分的陣列。</span><span class="sxs-lookup"><span data-stu-id="c2c50-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="c2c50-191">如果其中一個後續的路徑是絕對路徑，合併作業重設開頭的絕對路徑，並捨棄所有先前的結合的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="c2c50-192">如果 `paths` 中除了最後一個元素以外的任何元素不是磁碟機且結尾不是 <xref:System.IO.Path.DirectorySeparatorChar> 或 <xref:System.IO.Path.AltDirectorySeparatorChar> 字元，`Combine` 方法會將 <xref:System.IO.Path.DirectorySeparatorChar> 字元加在該元素與下一個字元之間。</span><span class="sxs-lookup"><span data-stu-id="c2c50-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="c2c50-193">請注意，如果元素結尾不是適用於目標平台路徑分隔符號字元，`Combine` 方法會保留原始的路徑分隔符號字元，並將附加支援的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="c2c50-194">下列範例會比較使用反斜線當做路徑分隔符號字元時 Windows 和 unix 系統上的結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="c2c50-195">長度為零的字串會省略的結合路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="c2c50-196">如果有泛空白字元，不會剖析參數。</span><span class="sxs-lookup"><span data-stu-id="c2c50-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="c2c50-197">並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="c2c50-198">例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="c2c50-199">它會因此順利解譯由`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="c2c50-200">下列範例會結合為一個路徑的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="c2c50-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-201">陣列中的一個字串包含在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-202">陣列中的一個字串為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-203">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-204">要合併的第一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-205">要合併的第二個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="c2c50-206">將兩個字串合併為一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-207">合併的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-207">The combined paths.</span></span> <span data-ttu-id="c2c50-208">如果指定的其中一個路徑是長度為零的字串，這個方法會傳回其他路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="c2c50-209">如果 <paramref name="path2" /> 包含絕對路徑，這個方法會傳回 <paramref name="path2" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-210">如果`path1`不是磁碟機參考 （也就是"C:"或"D:"） 和結尾不是有效的分隔符號字元如中所定義<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>附加至`path1`串連之前。</span><span class="sxs-lookup"><span data-stu-id="c2c50-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="c2c50-211">請注意，如果`path1`不適用於目標平台路徑分隔符號字元會停止於`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。</span><span class="sxs-lookup"><span data-stu-id="c2c50-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="c2c50-212">下列範例會比較使用反斜線當做路徑分隔符號字元時 Windows 和 unix 系統上的結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="c2c50-213">如果`path2`不包含根 (例如，如果`path2`開頭不是分隔符號字元或指定了磁碟機)，結果是串連兩個路徑中, 介的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="c2c50-214">如果`path2`包含根，`path2`會傳回。</span><span class="sxs-lookup"><span data-stu-id="c2c50-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="c2c50-215">如果有泛空白字元，不會剖析參數。</span><span class="sxs-lookup"><span data-stu-id="c2c50-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="c2c50-216">因此，如果`path2`包含泛空白字元 (例如，"\file.txt 」)，<xref:System.IO.Path.Combine%2A>方法會附加`path2`要`path1`而不是只傳回`path2`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="c2c50-217">並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="c2c50-218">例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="c2c50-219">它會因此順利解譯由`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="c2c50-220">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-221">下列範例示範如何使用`Combine`以 Windows 為基礎的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-222"><paramref name="path1" /> 或 <paramref name="path2" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個不正確字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-223"><paramref name="path1" /> 或 <paramref name="path2" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-224">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-225">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-226">HOW TO：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-227">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-228">要合併的第一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-229">要合併的第二個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="c2c50-230">要合併的第三個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="c2c50-231">將三個字串合併為一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-232">合併的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-233">`path1` 應該是絕對路徑 (例如，"d:\archives 」 或 「\\\archives\public")。</span><span class="sxs-lookup"><span data-stu-id="c2c50-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="c2c50-234">如果`path2`或`path3`也會重設為該絕對路徑與合併作業捨棄所有先前的結合路徑的絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="c2c50-235">長度為零的字串會省略的結合路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="c2c50-236">如果`path1`或是`path2`不是磁碟機參考 （也就是"C:"或"D:"） 和結尾不是有效的分隔符號字元如中所定義<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>附加至`path1`或`path2`串連之前。</span><span class="sxs-lookup"><span data-stu-id="c2c50-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="c2c50-237">請注意，如果`path1`或是`path2`不適用於目標平台路徑分隔符號字元會停止於`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。</span><span class="sxs-lookup"><span data-stu-id="c2c50-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="c2c50-238">下列範例會比較使用反斜線當做路徑分隔符號字元時 Windows 和 unix 系統上的結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="c2c50-239">如果`path2`不包含根 (例如，如果`path2`開頭不是分隔符號字元或指定了磁碟機)，結果是串連兩個路徑中, 介的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="c2c50-240">如果`path2`包含根，`path2`會傳回。</span><span class="sxs-lookup"><span data-stu-id="c2c50-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="c2c50-241">如果有泛空白字元，不會剖析參數。</span><span class="sxs-lookup"><span data-stu-id="c2c50-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="c2c50-242">因此，如果`path2`包含泛空白字元 (例如，"\file.txt 」)，<xref:System.IO.Path.Combine%2A>方法會附加`path2`至`path1`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="c2c50-243">並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="c2c50-244">例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="c2c50-245">它會因此順利解譯由`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-246">下列範例會結合三個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-247"><paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 包含一或多個在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-248"><paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-249">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-250">要合併的第一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-251">要合併的第二個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="c2c50-252">要合併的第三個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="c2c50-253">要合併的第四個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="c2c50-254">將四個字串合併為一個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-255">合併的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-256">`path1` 應該是絕對路徑 (例如，"d:\archives 」 或 「\\\archives\public")。如果其中一個後續的路徑也是絕對路徑，則合併作業會捨棄所有先前合併的路徑，並重設為該絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="c2c50-257">長度為零的字串會省略的結合路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="c2c50-258">如果`path1`， `path2`，或`path3`不是磁碟機參考 （也就是"C:"或"D:"） 和結尾不是有效的分隔符號字元如中所定義<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>會附加到其之前串連。</span><span class="sxs-lookup"><span data-stu-id="c2c50-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="c2c50-259">請注意，如果`path1`， `path2`，或`path3`不適用於目標平台路徑分隔符號字元會停止於`Combine`方法會保留原始的路徑分隔符號字元，並將附加支援。</span><span class="sxs-lookup"><span data-stu-id="c2c50-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="c2c50-260">下列範例會比較使用反斜線當做路徑分隔符號字元時 Windows 和 unix 系統上的結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="c2c50-261">如果`path2`不包含根 (例如，如果`path2`開頭不是分隔符號字元或指定了磁碟機)，結果是串連兩個路徑中, 介的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="c2c50-262">如果`path2`包含根，`path2`會傳回。</span><span class="sxs-lookup"><span data-stu-id="c2c50-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="c2c50-263">如果有泛空白字元，不會剖析參數。</span><span class="sxs-lookup"><span data-stu-id="c2c50-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="c2c50-264">因此，如果`path2`包含泛空白字元 (例如，"\file.txt 」)，<xref:System.IO.Path.Combine%2A>方法會附加`path2`至`path1`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="c2c50-265">並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Combine`方法，因為您可以使用這些字元搜尋萬用字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="c2c50-266">例如，當`Path.Combine("c:\\", "*.txt")`可能無效如果您要從中建立檔案，它是有效的搜尋字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="c2c50-267">它會因此順利解譯由`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-268">下列範例結合了四個路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-269"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 包含一或多個在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-270"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-271">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2c50-272">提供平台特定字元，用以在反映階層式檔案系統組織的路徑字串中分隔目錄層級。</span><span class="sxs-lookup"><span data-stu-id="c2c50-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="c2c50-273"><xref:System.IO.Path.AltDirectorySeparatorChar> 和`DirectorySeparatorChar`都適用於分隔的路徑字串中的目錄層級。</span><span class="sxs-lookup"><span data-stu-id="c2c50-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="c2c50-274">當您使用.NET Core 開發在多個平台執行的應用程式：</span><span class="sxs-lookup"><span data-stu-id="c2c50-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="c2c50-275">如果您想要硬式編碼的目錄分隔符號字元，您應該使用正斜線 (`/`) 字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="c2c50-276">它是唯一可辨識的目錄分隔符號字元在 Unix 系統上的輸出範例所示，並為<xref:System.IO.Path.AltDirectorySeparatorChar>在 Windows 上。</span><span class="sxs-lookup"><span data-stu-id="c2c50-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="c2c50-277">您可以使用字串串連來動態擷取路徑分隔符號字元，在執行階段，並將其整合到檔案系統路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="c2c50-278">例如，套用至物件的</span><span class="sxs-lookup"><span data-stu-id="c2c50-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="c2c50-279">您也可以擷取的值從<xref:System.IO.Path.AltDirectorySeparatorChar>屬性，因為它是在 Windows 和 Unx 為基礎的系統上相同。</span><span class="sxs-lookup"><span data-stu-id="c2c50-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="c2c50-280">擷取<xref:System.IO.Path.AltDirectorySeparatorChar>屬性</span><span class="sxs-lookup"><span data-stu-id="c2c50-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="c2c50-281">如果您的應用程式不是跨平台，您可以使用適用於您的系統的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="c2c50-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="c2c50-282">下列範例會顯示<xref:System.IO.Path>欄位在 Windows 和 unix 系統上的值。</span><span class="sxs-lookup"><span data-stu-id="c2c50-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="c2c50-283">請注意 Windows 支援正斜線 (所傳回的<xref:System.IO.Path.AltDirectorySeparatorChar>欄位) 或反斜線 (所傳回的<xref:System.IO.Path.DirectorySeparatorChar>欄位) 為路徑分隔符號字元，而以 Unix 為基礎的系統則支援正斜線。</span><span class="sxs-lookup"><span data-stu-id="c2c50-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-284">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-285">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-286">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-287">HOW TO：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="c2c50-288">傳回指定路徑字串的目錄資訊，此路徑以字元範圍表示。</span><span class="sxs-lookup"><span data-stu-id="c2c50-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="c2c50-289"><paramref name="path" /> 的目錄資訊、或 <paramref name="path" /> 為 <see langword="null" /> 則為空的範圍、空的範圍，或根目錄 (例如 \, C: 或 \\server\share)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-290">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-291">檔案或目錄的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="c2c50-292">傳回指定路徑字串的目錄資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="c2c50-293"><paramref name="path" /> 的目錄資訊；如果 <paramref name="path" /> 表示根目錄或為 null，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="c2c50-294">如果 <paramref name="path" /> 不包含目錄資訊，則傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-295">在大部分情況下，這個方法所傳回的字串所組成，但不是包括最後一個路徑中的所有字元<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="c2c50-296">如果路徑包含根目錄，例如"c:\\"，則會傳回 null。</span><span class="sxs-lookup"><span data-stu-id="c2c50-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="c2c50-297">請注意，這個方法並不支援使用的路徑 」 檔案:"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="c2c50-298">因為傳回的路徑不包含<xref:System.IO.Path.DirectorySeparatorChar>或是<xref:System.IO.Path.AltDirectorySeparatorChar>，將傳回的路徑傳遞回<xref:System.IO.Path.GetDirectoryName%2A>方法會導致每個後續的呼叫，在結果字串的一個資料夾層級的截斷。</span><span class="sxs-lookup"><span data-stu-id="c2c50-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="c2c50-299">例如，將路徑 「 C:\Directory\SubDirectory\test.txt"傳遞到<xref:System.IO.Path.GetDirectoryName%2A>方法會傳回"C:\Directory\SubDirectory 」。</span><span class="sxs-lookup"><span data-stu-id="c2c50-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="c2c50-300">將"C:\Directory\SubDirectory 」，該字串傳遞到<xref:System.IO.Path.GetDirectoryName%2A>會導致 「 C:\Directory"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="c2c50-301">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-302">下列範例示範如何使用`GetDirectoryName`以 Windows 為基礎的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-303"><paramref name="path" /> 參數包含無效字元、空白，或只包含空格。</span><span class="sxs-lookup"><span data-stu-id="c2c50-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="c2c50-304">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="c2c50-305"><paramref name="path" /> 參數超過系統定義的長度上限。</span><span class="sxs-lookup"><span data-stu-id="c2c50-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-306">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-307">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-308">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-309">HOW TO：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-310">可取得副檔名的檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-311">傳回檔案路徑的副檔名，此路徑以唯讀的字元範圍表示。</span><span class="sxs-lookup"><span data-stu-id="c2c50-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="c2c50-312">指定路徑的副檔名 (包括句點 ".")，如果 <paramref name="path" /> 沒有副檔名資訊，則為 <see cref="P:System.ReadOnlySpan`1.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c2c50-313">這個方法會取得的延伸模組`path`藉由搜尋`path`時間 ("。")，從 在唯讀模式的範圍中的最後一個字元，且繼續向其第一個字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="c2c50-314">如果之前找到一段<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>字元，傳回的唯讀範圍包含句點，並將字元之後，否則<xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>會傳回。</span><span class="sxs-lookup"><span data-stu-id="c2c50-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-315">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-316">要從中取得副檔名的路徑字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-317">傳回擴充功能 (包括句點"。") 的指定的路徑字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-317">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="c2c50-318">指定路徑的副檔名 (包括句點 ".")、<see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="c2c50-319">如果 <paramref name="path" /> 是 <see langword="null" />，則 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 會傳回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="c2c50-320">如果 <paramref name="path" /> 沒有副檔名資訊，則 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c2c50-321">這個方法會取得的延伸模組`path`藉由搜尋`path`開頭的最後一個字元的句號 （.），如`path`而繼續到第一個字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="c2c50-322">如果之前找到一段<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>字元，傳回的字串會包含句點，並將字元後，否則<xref:System.String.Empty?displayProperty=nameWithType>會傳回。</span><span class="sxs-lookup"><span data-stu-id="c2c50-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="c2c50-323">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="c2c50-324">下列範例示範如何使用`GetExtension`以 Windows 為基礎的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-325"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-326">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-327">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-328">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-329">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-330">包含路徑的唯讀範圍，這是取得檔案名稱和副檔名的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-331">傳回檔案路徑的檔案名稱和副檔名，此路徑以唯讀的字元範圍表示。</span><span class="sxs-lookup"><span data-stu-id="c2c50-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="c2c50-332"><paramref name="path" /> 中最後目錄分隔符號字元之後的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c2c50-333">傳回唯讀範圍包含的路徑，請依照下列中的最後一個分隔符號的字元`path`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="c2c50-334">如果最後一個字元`path`是磁碟區或目錄分隔符號字元，則方法會傳回<xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c2c50-335">如果`path`不包含任何分隔符號字元，則方法會傳回`path`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-336">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-337">要從中取得檔案名稱和副檔名的路徑字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-338">傳回指定路徑字串的檔案名稱和副檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="c2c50-339"><paramref name="path" /> 中最後目錄分隔符號字元之後的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="c2c50-340">如果 <paramref name="path" /> 的最後一個字元是目錄或磁碟區分隔符號字元，這個方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="c2c50-341">如果 <paramref name="path" /> 為 <see langword="null" />，這個方法會傳回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c2c50-342">傳回的值是`null`的檔案路徑是否`null`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="c2c50-343">用來判斷檔案名稱開頭的分隔符號字元<xref:System.IO.Path.DirectorySeparatorChar>和<xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="c2c50-344">因為*\\* Unix 上是合法的檔名`GetFileName`下以 Unix 為基礎的平台執行無法正確地傳回檔案名稱，從以 Windows 為基礎的路徑，例如*c:\\mydir\\myfile.ext*，但`GetFileName`下以 Windows 為基礎的平台執行可以正確地傳回檔案名稱，從以 Unix 為基礎的路徑，例如 */tmp/myfile.ext*，因此行為`GetFileName`方法不完全是以 Unix 為基礎和以 Windows 為基礎的平台上相同。</span><span class="sxs-lookup"><span data-stu-id="c2c50-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="c2c50-345">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-346">下列範例示範的行為`GetFileName`以 Windows 為基礎的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-347"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-348">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-349">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-350">HOW TO：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-351">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-352">包含路徑的唯讀範圍，可從該路徑取得沒有副檔名的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-353">傳回檔案路徑的檔案名稱和副檔名，此路徑以唯讀的字元範圍表示。</span><span class="sxs-lookup"><span data-stu-id="c2c50-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="c2c50-354"><see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> 傳回的唯讀範圍字元，不含最後的句號 (.) 以及其後所有字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-355">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-356">檔案的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="c2c50-357">傳回沒有副檔名的指定路徑字串的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="c2c50-358"><see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> 傳回的字串，但不包含最後的句號 (.) 以及其後的所有字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-359">這個方法不會驗證路徑或檔案名稱已經存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="c2c50-360">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-361">下列範例示範使用`GetFileNameWithoutExtension`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-362"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-363">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-364">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-365">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-366">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-367">要為其取得絕對路徑資訊的檔案或目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="c2c50-368">傳回指定路徑字串的絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="c2c50-369"><paramref name="path" /> 的完整位置，例如 "C:\MyFile.txt"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="c2c50-370">絕對路徑包括尋找檔案或目錄的系統上所需的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="c2c50-371">指定檔案或目錄的`path`不一定要存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="c2c50-372">例如，如果*c:\temp\newdir*是目前的目錄中，呼叫`GetFullPath`檔案名稱，例如*test.txt*傳回*c:\temp\newdir\test.txt*。</span><span class="sxs-lookup"><span data-stu-id="c2c50-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="c2c50-373">檔案必須存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="c2c50-374">如果`path`是相對路徑，這個多載會傳回可以根據目前的磁碟機和目前的目錄的完整的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="c2c50-375">當應用程式執行時，可以會隨時變更目前磁碟機和目前的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="c2c50-376">如此一來，無法事先判斷這個多載所傳回的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="c2c50-377">若要傳回具有決定性的路徑，請呼叫<xref:System.IO.Path.GetFullPath(System.String,System.String)>多載。</span><span class="sxs-lookup"><span data-stu-id="c2c50-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="c2c50-378">您也可以呼叫<xref:System.IO.Path.IsPathFullyQualified%2A>方法，以判斷是否路徑完整或相對路徑，因此是否呼叫`GetFullPath`必不可少。</span><span class="sxs-lookup"><span data-stu-id="c2c50-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="c2c50-379">不過，如果`path`存在，呼叫端必須具有權限，來取得路徑資訊`path`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="c2c50-380">請注意，不同於大部分成員<xref:System.IO.Path>類別，這個方法會存取檔案系統。</span><span class="sxs-lookup"><span data-stu-id="c2c50-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="c2c50-381">這個方法會使用目前的目錄及磁碟區上的最新資訊來完整限定`path`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="c2c50-382">如果您指定的檔案只能在命名`path`，`GetFullPath`傳回目前目錄的完整的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="c2c50-383">如果您傳入短檔名時，會將它擴展為長檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="c2c50-384">如果路徑不包含任何有效字元數，它無效，除非它包含一或多個"。"字元後面接著任何數目的空格;然後它會剖析為 」。 「 或 」...」。</span><span class="sxs-lookup"><span data-stu-id="c2c50-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="c2c50-385">.NET core 1.1 和更新版本以及.NET Framework 4.6.2 和更新版本也支援路徑，包括裝置名稱，例如"\\？ \C:\"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="c2c50-386">如需有關在 Windows 上的檔案路徑格式的詳細資訊，請參閱 <<c0> [ 在 Windows 系統上的檔案路徑格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="c2c50-387">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="c2c50-388">下列範例示範`GetFullPath`以 Windows 為基礎的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-389"><paramref name="path" /> 是長度為零的字串、只包含空白字元，或包含在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="c2c50-390">-或-</span><span class="sxs-lookup"><span data-stu-id="c2c50-390">-or-</span></span> 
<span data-ttu-id="c2c50-391">系統可能不會擷取絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c2c50-392">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="c2c50-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-393"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c2c50-394"><paramref name="path" /> 含有不屬於磁碟區識別碼 (例如 "c:\\") 一部分的冒號 (":")。</span><span class="sxs-lookup"><span data-stu-id="c2c50-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="c2c50-395">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</span><span class="sxs-lookup"><span data-stu-id="c2c50-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c2c50-396">存取路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-397">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-398">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-399">HOW TO：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-400">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-401">串連成 <paramref name="basePath" /> 的相對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-401">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="c2c50-402">完整路徑的開頭。</span><span class="sxs-lookup"><span data-stu-id="c2c50-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="c2c50-403">從完整的基底路徑和相對路徑傳回絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-404">絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c2c50-405">如果`path`是空的路徑，此方法會傳回`basePath`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="c2c50-406">如果`path`是完整的路徑，方法傳遞`path`到<xref:System.IO.Path.GetFullPath(System.String)>方法，並傳回結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="c2c50-407">使用此方法來傳回具決定性的路徑會根據指定的磁碟區和根目錄的目錄，當您使用相對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="c2c50-408">使用預先定義`basePath`而不是目前的磁碟機目錄可防範因非預期的變更，在目前的磁碟機和目錄的不必要的檔案路徑為基礎。</span><span class="sxs-lookup"><span data-stu-id="c2c50-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="c2c50-409">範例</span><span class="sxs-lookup"><span data-stu-id="c2c50-409">Example</span></span>

<span data-ttu-id="c2c50-410">下列範例會定義一個變數， `basePath`，以代表應用程式的目前的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="c2c50-411">它接著將它傳遞給`GetFullPath`方法來取得應用程式的資料目錄的完整的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-412"><paramref name="path" /> 或 <paramref name="basePath" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-413"><paramref name="basePath" /> 不是完整路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="c2c50-414">-或-</span><span class="sxs-lookup"><span data-stu-id="c2c50-414">-or-</span></span>

<span data-ttu-id="c2c50-415"><paramref name="path" /> 或 <paramref name="basePath" /> 包含無效的路徑字元，例如 U+0000。</span><span class="sxs-lookup"><span data-stu-id="c2c50-415"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2c50-416">取得陣列，該陣列包含檔案名稱中不允許的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-416">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="c2c50-417">陣列，該陣列包含檔案名稱中不允許的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-417">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-418">不保證此方法傳回的陣列包含一組完整的檔案和目錄名稱中無效的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-418">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="c2c50-419">完整的 無效的字元可能會因檔案系統。</span><span class="sxs-lookup"><span data-stu-id="c2c50-419">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="c2c50-420">例如，在 Windows 架構桌面平台上無效路徑字元可能會包括 ASCII/Unicode 字元 1 到 31，以及加上引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0) 和定位字元 (\t)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-420">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-421">下列範例示範<xref:System.IO.Path.GetInvalidFileNameChars%2A>方法和<xref:System.IO.Path.GetInvalidPathChars%2A>方法來擷取無效的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-421">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2c50-422">取得陣列，該陣列包含路徑名稱中不允許的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-422">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="c2c50-423">陣列，該陣列包含路徑名稱中不允許的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-423">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-424">不保證此方法傳回的陣列包含一組完整的檔案和目錄名稱中無效的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-424">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="c2c50-425">完整的 無效的字元可能會因檔案系統。</span><span class="sxs-lookup"><span data-stu-id="c2c50-425">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="c2c50-426">例如，在 Windows 架構桌面平台上無效路徑字元可能會包括 ASCII/Unicode 字元 1 到 31，以及加上引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0) 和定位字元 (\t)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-426">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-427">下列範例示範<xref:System.IO.Path.GetInvalidFileNameChars%2A>方法和<xref:System.IO.Path.GetInvalidPathChars%2A>方法來擷取無效的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-427">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-428">要從中取得根目錄資訊的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-428">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="c2c50-429">從所指定字元範圍中包含的路徑取得根目錄資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-429">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="c2c50-430">包含 `path` 之根目錄的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-430">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-431">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-431">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-432">要從中取得根目錄資訊的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-432">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="c2c50-433">取得指定路徑的根目錄資訊。</span><span class="sxs-lookup"><span data-stu-id="c2c50-433">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-434"><paramref name="path" /> 的根目錄，或如果 <paramref name="path" /> 為 <see langword="null" />，則為 <see langword="null" />，或如果 <paramref name="path" /> 不包含根目錄資訊，則為空字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-434">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-435">這個方法不會驗證路徑或檔案名稱已經存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-435">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="c2c50-436">可能的模式，這個方法所傳回的字串如下所示：</span><span class="sxs-lookup"><span data-stu-id="c2c50-436">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="c2c50-437">空字串 (`path`目前磁碟機或磁碟區上所指定的相對路徑)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-437">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="c2c50-438">「\" (`path`目前的磁碟機上指定的絕對路徑)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-438">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="c2c50-439">"X"(`path`指定為相對路徑上的磁碟機，其中 X 代表磁碟機或磁碟區代號)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-439">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="c2c50-440">"X:\" (`path`指定磁碟機上指定的絕對路徑)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-440">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="c2c50-441">"\\\ComputerName\SharedFolder" (a UNC path).</span><span class="sxs-lookup"><span data-stu-id="c2c50-441">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="c2c50-442">「\\？ \C: 」 （DOS 裝置路徑，在.NET Core 1.1 和更新版本和.NET Framework 4.6.2 和更新版本支援）</span><span class="sxs-lookup"><span data-stu-id="c2c50-442">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="c2c50-443">如需有關在 Windows 上的檔案路徑的詳細資訊，請參閱 <<c0> [ 在 Windows 系統上的檔案路徑格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-443">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="c2c50-444">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-444">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="c2c50-445">下列範例示範使用`GetPathRoot`方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-445">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-446"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-446"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="c2c50-447">-或-</span><span class="sxs-lookup"><span data-stu-id="c2c50-447">-or-</span></span> 
 <span data-ttu-id="c2c50-448">已將 <see cref="F:System.String.Empty" /> 傳遞給 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-448"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-449">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-449">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-450">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-450">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-451">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-451">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-452">HOW TO：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-452">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2c50-453">傳回隨機資料夾名稱或檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-453">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="c2c50-454">隨機資料夾名稱或檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-454">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-455"><xref:System.IO.Path.GetRandomFileName%2A>方法會傳回可用來當做資料夾名稱或檔案名稱的密碼編譯方面強式的隨機字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-455">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="c2c50-456">不同於<xref:System.IO.Path.GetTempFileName%2A>，<xref:System.IO.Path.GetRandomFileName%2A>不會建立檔案。</span><span class="sxs-lookup"><span data-stu-id="c2c50-456">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="c2c50-457">而不是最重要的檔案系統的安全性時，應該使用這個方法<xref:System.IO.Path.GetTempFileName%2A>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-457">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-458">下列範例顯示輸出來源<xref:System.IO.Path.GetRandomFileName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-458">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="c2c50-459">應與結果相對的來源路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-459">The source path the result should be relative to.</span></span> <span data-ttu-id="c2c50-460">此路徑一律視為目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-460">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="c2c50-461">目的地路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-461">The destination path.</span></span></param>
        <summary><span data-ttu-id="c2c50-462">傳回某個路徑到另一個路徑的相對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-462">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="c2c50-463">如果路徑不共用相同的根目錄，則為相對路徑或 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-463">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c2c50-464">路徑會解析藉由呼叫<xref:System.IO.Path.GetFullPath%2A>方法，然後再計算的差異。</span><span class="sxs-lookup"><span data-stu-id="c2c50-464">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="c2c50-465">方法會使用預設的檔案路徑比較目前的平台 (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>適用於 Windows 和 MacOs，<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>適用於 Linux。</span><span class="sxs-lookup"><span data-stu-id="c2c50-465">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-466"><paramref name="relativeTo" /> 或 <paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-466"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-467">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-467">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2c50-468">在磁碟上建立具名之零位元組的唯一暫存檔案，然後傳回該檔案的完整路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-468">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="c2c50-469">暫存檔案的完整路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-469">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-470">這個方法會建立暫存檔案。TMP 檔案的副檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-470">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="c2c50-471">暫存的檔案會建立在使用者的暫存資料夾中，也就是路徑傳回<xref:System.IO.Path.GetTempPath%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-471">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="c2c50-472"><xref:System.IO.Path.GetTempFileName%2A>方法會引發<xref:System.IO.IOException>如果它用來建立超過 65535 的檔案，而不會刪除先前的暫存檔案。</span><span class="sxs-lookup"><span data-stu-id="c2c50-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="c2c50-473"><xref:System.IO.Path.GetTempFileName%2A>方法會引發<xref:System.IO.IOException>沒有唯一暫存檔案名稱是否可用。</span><span class="sxs-lookup"><span data-stu-id="c2c50-473">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="c2c50-474">若要解決這個錯誤，刪除所有不必要的暫存檔案。</span><span class="sxs-lookup"><span data-stu-id="c2c50-474">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="c2c50-475">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-475">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c2c50-476">發生 I/O 錯誤，例如沒有可用的唯一暫存檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="c2c50-476">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="c2c50-477">-或-</span><span class="sxs-lookup"><span data-stu-id="c2c50-477">-or-</span></span> 
<span data-ttu-id="c2c50-478">這個方法無法建立暫存檔案。</span><span class="sxs-lookup"><span data-stu-id="c2c50-478">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c2c50-479">用於寫入到暫存目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-479">for writing to the temporary directory.</span></span> <span data-ttu-id="c2c50-480">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="c2c50-480">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-481">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-481">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-482">HOW TO：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-482">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-483">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-483">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2c50-484">傳回目前使用者的暫存資料夾路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-484">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="c2c50-485">暫存資料夾的路徑，結尾是反斜線。</span><span class="sxs-lookup"><span data-stu-id="c2c50-485">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-486">這個方法會檢查存在的環境變數，以下列順序，並使用找到的第一個路徑：</span><span class="sxs-lookup"><span data-stu-id="c2c50-486">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="c2c50-487">TMP 環境變數所指定的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-487">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="c2c50-488">TEMP 環境變數所指定的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-488">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="c2c50-489">USERPROFILE 環境變數所指定的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-489">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="c2c50-490">Windows 目錄中。</span><span class="sxs-lookup"><span data-stu-id="c2c50-490">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-491">下列程式碼將示範如何呼叫 <xref:System.IO.Path.GetTempPath%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-491">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="c2c50-492">此範例會產生類似下列的輸出。</span><span class="sxs-lookup"><span data-stu-id="c2c50-492">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c2c50-493">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="c2c50-493">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="c2c50-494">不受限制存取環境變數。</span><span class="sxs-lookup"><span data-stu-id="c2c50-494">for unrestricted access to environment variables.</span></span> <span data-ttu-id="c2c50-495">相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="c2c50-495">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-496">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-496">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-497">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-497">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-498">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-498">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-499">要在其中搜尋副檔名的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-499">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-500">判斷指定字元範圍所表示的路徑是否包含副檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-500">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="c2c50-501">如果路徑中接在最後一個目錄分隔符號字元或磁碟區分隔符號之後的字元包含句號 (".")，且後面接著一或多個字元，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-501"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c2c50-502">在 結尾的句點`path`不是延伸模組。</span><span class="sxs-lookup"><span data-stu-id="c2c50-502">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-503">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-503">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-504">要在其中搜尋副檔名的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-504">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="c2c50-505">判斷路徑是否包括副檔名。</span><span class="sxs-lookup"><span data-stu-id="c2c50-505">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="c2c50-506">如果路徑中接在最後一個目錄分隔符號 (\\\ 或 /) 或磁碟區分隔符號 (:) 之後的字元包含句號 (.)，且後面接著一或多個字元，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-506"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-507">從結尾開始`path`，這個方法會搜尋後面至少一個字元的句號 （.）。</span><span class="sxs-lookup"><span data-stu-id="c2c50-507">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="c2c50-508">如果此模式之前找到<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>遇到字元，則這個方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-508">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="c2c50-509">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-509">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-510">下列範例示範 `HasExtension` 方法的用法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-510">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-511"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-511"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-512">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-512">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-513">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-514">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-515">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2c50-516">提供字元的平台特定陣列，這些字元不可以在傳遞給 <see cref="T:System.IO.Path" /> 類別成員的路徑字串引數中指定。</span><span class="sxs-lookup"><span data-stu-id="c2c50-516">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-517">不保證此方法傳回的陣列包含一組完整的檔案和目錄名稱中無效的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-517">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="c2c50-518">完整的 無效的字元可能會因檔案系統。</span><span class="sxs-lookup"><span data-stu-id="c2c50-518">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="c2c50-519">例如，在 Windows 架構桌面平台上無效路徑字元可能會包括 ASCII/Unicode 字元 1 到 31，以及加上引號 （"）、 小於 (\<)、 大於 (>)、 管道 (&#124;)、 退格鍵 (\b)、 null (\0) 和定位字元 (\t)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-519">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c2c50-520">請勿使用<xref:System.IO.Path.InvalidPathChars>如果您認為您的程式碼可能會執行相同的應用程式定義域，即不受信任的程式碼中。</span><span class="sxs-lookup"><span data-stu-id="c2c50-520">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="c2c50-521"><xref:System.IO.Path.InvalidPathChars> 是陣列，所以其項目將會覆寫。</span><span class="sxs-lookup"><span data-stu-id="c2c50-521"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="c2c50-522">如果不受信任的程式碼會覆寫的項目<xref:System.IO.Path.InvalidPathChars>，它可能會導致您的程式碼，可能會遭到使用者的方式運作不正常。</span><span class="sxs-lookup"><span data-stu-id="c2c50-522">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-523">下列範例示範如何使用`InvalidPathChars`屬性。</span><span class="sxs-lookup"><span data-stu-id="c2c50-523">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-524">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-524">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-525">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-525">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-526">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-526">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="c2c50-527">傳回值，指出檔案路徑是否為完整路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-527">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="c2c50-528">多載`IsPathFullyQualified`同時使用的方法控制代碼路徑<xref:System.IO.Path.DirectorySeparatorChar>而<xref:System.IO.Path.AltDirectorySeparatorChar>字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-528">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="c2c50-529">它不會做為引數傳遞給它的路徑上執行任何驗證。</span><span class="sxs-lookup"><span data-stu-id="c2c50-529">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="c2c50-530">如此一來，Uri 會解譯為相對路徑，並傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-530">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="c2c50-531">沒有差異的完整路徑 (如所示`IsPathFullyQualified`方法) 和根的路徑 (如所示<xref:System.IO.Path.IsPathRooted%2A>方法)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-531">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="c2c50-532">A*完整的路徑*或是*絕對路徑*一律定義確切路徑從特定的磁碟機或裝置的目標檔案或目錄，並不相依於目前的磁碟機或目前的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-532">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="c2c50-533">例如，在 Windows 系統上*C:/users/user1/documents/reports/2019/january/highlights.pdf*定義目標檔案中，從 c： 磁碟機的根目錄的絕對路徑*highlights.pdf*。</span><span class="sxs-lookup"><span data-stu-id="c2c50-533">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="c2c50-534">A*根的路徑*指定起始磁碟機或根目錄，但取決於目前的目錄 （如果它已進行 root 破解，所指定的磁碟機） 或目前的磁碟機 （如果它已進行 root 破解的根目錄）。</span><span class="sxs-lookup"><span data-stu-id="c2c50-534">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="c2c50-535">下列範例說明完整的路徑與根目錄的路徑之間的差異。</span><span class="sxs-lookup"><span data-stu-id="c2c50-535">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-536">檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-536">A file path.</span></span></param>
        <summary><span data-ttu-id="c2c50-537">傳回值，指出指定字元範圍所表示的檔案路徑是否固定在特定的磁碟機或 UNC 路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-537">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-538">如果路徑固定在特定的磁碟機或 UNC 路徑，則為 <see langword="true" />；如果路徑相對於目前的磁碟機或工作目錄，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-538"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-539">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-539">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-540">檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-540">A file path.</span></span></param>
        <summary><span data-ttu-id="c2c50-541">傳回值，指出指定的檔案路徑是否固定在特定磁碟機或 UNC 路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-541">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-542">如果路徑固定在特定的磁碟機或 UNC 路徑，則為 <see langword="true" />；如果路徑相對於目前的磁碟機或工作目錄，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-542"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2c50-543"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-543"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-544">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-544">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="c2c50-545">傳回值，指出檔案路徑是否包含根目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-545">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="c2c50-546">A**根的路徑**是檔案路徑，會固定為特定磁碟機或 UNIC 路徑; 它有別於目前的磁碟機或工作目錄的相對路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-546">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="c2c50-547">比方說，在 Windows 系統上根的路徑則會使用反斜線 (比方說，「 \Documents") 或磁碟機代號和冒號 (例如，"C:Documents 」) 開始。</span><span class="sxs-lookup"><span data-stu-id="c2c50-547">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="c2c50-548">請注意，根的路徑可以 （也就，完整名稱） 的絕對或相對。</span><span class="sxs-lookup"><span data-stu-id="c2c50-548">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="c2c50-549">絕對的根的路徑是從磁碟機根目錄到特定的目錄完整的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-549">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="c2c50-550">相對的根的路徑指定磁碟機，但其完整的路徑會解析對目前的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-550">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="c2c50-551">下列範例會說明其間的差異。</span><span class="sxs-lookup"><span data-stu-id="c2c50-551">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-552">要測試的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-552">The path to test.</span></span></param>
        <summary><span data-ttu-id="c2c50-553">傳回值，指出所指定字元範圍所表示的檔案路徑是否包含根目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-553">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="c2c50-554">如果 <paramref name="path" /> 包含根目錄，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-554"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-555">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-555">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c2c50-556">要測試的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-556">The path to test.</span></span></param>
        <summary><span data-ttu-id="c2c50-557">傳回值，指出指定的路徑字串是否包含根目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-557">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="c2c50-558">如果 <paramref name="path" /> 包含根目錄，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-558"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-559"><xref:System.IO.Path.IsPathRooted%2A>方法會傳回`true`如果第一個字元是目錄分隔符號字元如 「\\"，或如果路徑的開頭的磁碟機代號和冒號 （:）。</span><span class="sxs-lookup"><span data-stu-id="c2c50-559">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="c2c50-560">比方說，它會傳回`true`for`path`這類字串 」\\\MyDir\\\MyFile.txt"，"c:\\\MyDir"，或 「 C:MyDir"。</span><span class="sxs-lookup"><span data-stu-id="c2c50-560">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="c2c50-561">它會傳回`false`針對`path`"MyDir"等字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-561">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="c2c50-562">這個方法不會驗證路徑或檔案名稱已經存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-562">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="c2c50-563">如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="c2c50-563">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="c2c50-564">下列範例示範如何`IsPathRooted`方法可用來測試三個字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-564">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2c50-565"><paramref name="path" /> 含有在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定義的一或多個無效字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-565"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-566">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-566">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-567">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-567">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-568">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-568">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-569">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-569">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-570">包含第一個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-570">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-571">包含第二個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-571">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="c2c50-572">將兩個路徑元件串連成單一路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-572">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="c2c50-573">合併的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-573">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="c2c50-574">這個方法只是串連`path`並`path2`並新增兩個路徑元件之間的目錄分隔符號字元，如果尚未存在的結尾`path1`處或開端`path2`。</span><span class="sxs-lookup"><span data-stu-id="c2c50-574">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="c2c50-575">如果<xref:System.ReadOnlySpan%601.Length>任一`path1`或`path2`為零，則方法會傳回其他路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-575">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="c2c50-576">如果<xref:System.ReadOnlySpan%601.Length>兩者`path1`並`path2`為零，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-576">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="c2c50-577">如果`path1`不適用於目標平台路徑分隔符號字元會停止於`Join`方法會保留原始的路徑分隔符號字元，並將附加支援。</span><span class="sxs-lookup"><span data-stu-id="c2c50-577">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="c2c50-578">使用 Windows 反斜線的硬式編碼路徑中就會發生此問題 (「\") 無法辨識以 Unix 為基礎的系統做為路徑分隔符號的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-578">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="c2c50-579">若要解決此問題，您可以：</span><span class="sxs-lookup"><span data-stu-id="c2c50-579">To work around this issue, you can:</span></span>

- <span data-ttu-id="c2c50-580">擷取值的<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，而不是硬式編碼是目錄分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-580">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="c2c50-581">您可以使用正斜線 （"/"） 作為目錄分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-581">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="c2c50-582">此字元由<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，以 Unix 為基礎的系統上並由<xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>Windows 系統上的屬性。</span><span class="sxs-lookup"><span data-stu-id="c2c50-582">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="c2c50-583">不同於<xref:System.IO.Path.Combine%2A>方法，<xref:System.IO.Path.Join%2A>方法並不會嘗試傳回的路徑的根目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-583">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="c2c50-584">(亦即，如果`path2`是絕對路徑，`Join`方法不會捨棄`path1`，並傳回`path2`做為<xref:System.IO.Path.Combine%2A>方法會執行。)下列範例說明兩個方法所傳回之路徑的差異。</span><span class="sxs-lookup"><span data-stu-id="c2c50-584">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="c2c50-585">如果來源的`path2`是使用者輸入<xref:System.IO.Path.Combine%2A>方法可讓使用者存取檔案系統資源 (例如*c: / 使用者/User1/文件/財務/* 在此範例的情況下) 的應用程式不想要讓可供存取。</span><span class="sxs-lookup"><span data-stu-id="c2c50-585">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="c2c50-586">並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Join`方法，因為您可以使用這些字元搜尋萬用字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-586">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="c2c50-587">例如，當`Path.Join("c:\\", "*.txt")`可能會不正確時建立檔案，它是有效的搜尋字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-587">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="c2c50-588">`Join`方法因此成功地將它解譯。</span><span class="sxs-lookup"><span data-stu-id="c2c50-588">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="c2c50-589">範例</span><span class="sxs-lookup"><span data-stu-id="c2c50-589">Example</span></span>

<span data-ttu-id="c2c50-590">下列範例說明在所傳回的路徑中的差異<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType>和<xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-590">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c2c50-591">當第一個字串是包含磁碟機和根目錄的目錄完整的路徑和第二個是從第一個路徑的相對路徑時，這兩個方法會產生相同的結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-591">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="c2c50-592">在第二個和第三個呼叫`ShowPathInformation`方法，這兩個方法所傳回的字串會分離開來。</span><span class="sxs-lookup"><span data-stu-id="c2c50-592">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="c2c50-593">在第二個方法呼叫中，第一個字串引數是磁碟機，而第二個是根目錄的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-593">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="c2c50-594">`Join`方法串連兩個字串，並且保留重複的路徑分隔符號。</span><span class="sxs-lookup"><span data-stu-id="c2c50-594">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="c2c50-595">`Combine`方法放棄磁碟機，並傳回目前的磁碟機的根目錄的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-595">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="c2c50-596">如果應用程式的目前磁碟機是 C:\字串用來存取檔案或目錄中的檔案，它會存取而不是 d: c:。</span><span class="sxs-lookup"><span data-stu-id="c2c50-596">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="c2c50-597">最後，因為第三個呼叫中的兩個引數`ShowPathInformation`的根目錄`Join`方法只是將它們附加若要建立無意義的檔案路徑，而`Combine`方法就會捨棄第一個字串，並傳回第二個。</span><span class="sxs-lookup"><span data-stu-id="c2c50-597">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="c2c50-598">使用此字串的檔案存取可以讓應用程式非預期的存取機密的檔案。</span><span class="sxs-lookup"><span data-stu-id="c2c50-598">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-599">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-599">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-600">包含第一個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-600">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-601">包含第二個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-601">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="c2c50-602">包含第三個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-602">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="c2c50-603">將三個路徑元件串連成單一路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-603">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="c2c50-604">這個方法只是串連`path`， `path2`，和`path3`並新增任何路徑元件之間的目錄分隔符號字元，如果尚未存在。</span><span class="sxs-lookup"><span data-stu-id="c2c50-604">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="c2c50-605">如果<xref:System.ReadOnlySpan%601.Length>任一`path1`， `path2`，或`path3`引數為零，則方法會串連其餘引數。</span><span class="sxs-lookup"><span data-stu-id="c2c50-605">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="c2c50-606">如果<xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType>的所有元件為零，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="c2c50-606">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="c2c50-607">如果`path1`或是`path2`不適用於目標平台路徑分隔符號字元結尾`Join`方法會保留原始的路徑分隔符號字元，並將附加支援。</span><span class="sxs-lookup"><span data-stu-id="c2c50-607">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="c2c50-608">使用 Windows 反斜線的硬式編碼路徑中就會發生此問題 (「\") 無法辨識以 Unix 為基礎的系統做為路徑分隔符號的字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-608">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="c2c50-609">若要解決此問題，您可以：</span><span class="sxs-lookup"><span data-stu-id="c2c50-609">To work around this issue, you can:</span></span>

- <span data-ttu-id="c2c50-610">擷取值的<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，而不是硬式編碼是目錄分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-610">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="c2c50-611">您可以使用正斜線 （"/"） 作為目錄分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-611">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="c2c50-612">此字元由<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>屬性，以 Unix 為基礎的系統上並由<xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>Windows 系統上的屬性。</span><span class="sxs-lookup"><span data-stu-id="c2c50-612">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="c2c50-613">不同於<xref:System.IO.Path.Combine%2A>方法，<xref:System.IO.Path.Join%2A>方法並不會嘗試傳回的路徑的根目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-613">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="c2c50-614">(亦即，如果`path2`或是`path2`是絕對路徑，`Join`方法不會捨棄先前的路徑為<xref:System.IO.Path.Combine%2A>方法會執行。</span><span class="sxs-lookup"><span data-stu-id="c2c50-614">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="c2c50-615">並非所有的目錄和檔案名稱無效的字元會解譯為接受由`Join`方法，因為您可以使用這些字元搜尋萬用字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-615">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="c2c50-616">例如，當`Path.Join("c:\\", "temp", "*.txt")`可能會不正確時建立檔案，它是有效的搜尋字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-616">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="c2c50-617">`Join`方法因此成功地將它解譯。</span><span class="sxs-lookup"><span data-stu-id="c2c50-617">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="c2c50-618">範例</span><span class="sxs-lookup"><span data-stu-id="c2c50-618">Example</span></span>

<span data-ttu-id="c2c50-619">下列範例說明在所傳回的路徑中的差異<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType>和<xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="c2c50-619">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c2c50-620">當第一個字串是包含磁碟機和根目錄的目錄完整的路徑和第二個是從第一個路徑的相對路徑時，這兩個方法會產生相同的結果。</span><span class="sxs-lookup"><span data-stu-id="c2c50-620">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="c2c50-621">在第二個和第三個呼叫`ShowPathInformation`方法，這兩個方法所傳回的字串會分離開來。</span><span class="sxs-lookup"><span data-stu-id="c2c50-621">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="c2c50-622">在第二個方法呼叫中，第一個字串引數是磁碟機，而第二個是根目錄的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-622">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="c2c50-623">`Join`方法串連兩個字串，並且保留重複的路徑分隔符號。</span><span class="sxs-lookup"><span data-stu-id="c2c50-623">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="c2c50-624">呼叫<xref:System.IO.Path.GetFullPath%2A>方法會排除重複項目。</span><span class="sxs-lookup"><span data-stu-id="c2c50-624">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="c2c50-625">`Combine`方法放棄磁碟機，並傳回目前的磁碟機的根目錄的目錄。</span><span class="sxs-lookup"><span data-stu-id="c2c50-625">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="c2c50-626">如果應用程式的目前磁碟機是 C:\字串用來存取檔案或目錄中的檔案，它會存取而不是 d: c:。</span><span class="sxs-lookup"><span data-stu-id="c2c50-626">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="c2c50-627">最後，因為第三個呼叫中的最後一個引數`ShowPathInformation`已進行 root 破解，`Join`方法只會將其附加的前兩個引數來建立無意義的檔案路徑，而`Combine`方法會捨棄的前兩個字串，並傳回第三個。</span><span class="sxs-lookup"><span data-stu-id="c2c50-627">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="c2c50-628">使用此字串的檔案存取可以讓應用程式非預期的存取機密的檔案。</span><span class="sxs-lookup"><span data-stu-id="c2c50-628">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-629">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-629">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2c50-630">平台特定分隔符號字元，用來分隔環境變數中的路徑字串。</span><span class="sxs-lookup"><span data-stu-id="c2c50-630">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-631">在 Windows 架構桌面平台上，這個欄位的值是分號 （;） 根據預設，但其他平台上可能會有所不同。</span><span class="sxs-lookup"><span data-stu-id="c2c50-631">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-632">下列範例示範如何使用`PathSeparator`欄位。</span><span class="sxs-lookup"><span data-stu-id="c2c50-632">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-633">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-633">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-634">作法：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-634">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-635">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-635">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="c2c50-636">嘗試將個別路徑元件串連成預先配置的字元範圍，然後傳回值，指出作業是否成功。</span><span class="sxs-lookup"><span data-stu-id="c2c50-636">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="c2c50-637">目的地字元範圍必須足以容納串連的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-637">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="c2c50-638">接著您可以藉由呼叫擷取串連的路徑<xref:System.Span%601.Slice%2A?displayProperty=nameWithType>方法，如下列範例會示範。</span><span class="sxs-lookup"><span data-stu-id="c2c50-638">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-639">包含第一個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-639">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-640">包含第二個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-640">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="c2c50-641">保留串連路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-641">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="c2c50-642">當方法傳回值時，該值會指出寫入 <paramref name="destination" /> 的字元數目。</span><span class="sxs-lookup"><span data-stu-id="c2c50-642">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="c2c50-643">嘗試將兩個路徑元件串連成單一預先配置的字元範圍，然後傳回值，指出作業是否成功。</span><span class="sxs-lookup"><span data-stu-id="c2c50-643">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="c2c50-644">如果串連作業成功，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-644"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="c2c50-645">`destination` 必須足以容納串連的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-645">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="c2c50-646">接著您可以藉由呼叫擷取串連的路徑<xref:System.Span%601.Slice%2A?displayProperty=nameWithType>方法，為此範例說明。</span><span class="sxs-lookup"><span data-stu-id="c2c50-646">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-647">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-647">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="c2c50-648">包含第一個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-648">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="c2c50-649">包含第二個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-649">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="c2c50-650">包含第三個聯結路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-650">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="c2c50-651">保留串連路徑的字元範圍。</span><span class="sxs-lookup"><span data-stu-id="c2c50-651">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="c2c50-652">當方法傳回值時，該值會指出寫入 <paramref name="destination" /> 的字元數目。</span><span class="sxs-lookup"><span data-stu-id="c2c50-652">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="c2c50-653">嘗試將兩個路徑元件串連成單一預先配置的字元範圍，然後傳回值，指出作業是否成功。</span><span class="sxs-lookup"><span data-stu-id="c2c50-653">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="c2c50-654">如果串連作業成功，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c2c50-654"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="c2c50-655">`destination` 必須足以容納串連的路徑。</span><span class="sxs-lookup"><span data-stu-id="c2c50-655">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="c2c50-656">接著您可以藉由呼叫擷取串連的路徑<xref:System.Span%601.Slice%2A?displayProperty=nameWithType>方法，為此範例說明。</span><span class="sxs-lookup"><span data-stu-id="c2c50-656">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="c2c50-657">Windows 系統上的檔案路徑格式</span><span class="sxs-lookup"><span data-stu-id="c2c50-657">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2c50-658">提供平台特定磁碟區分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="c2c50-658">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2c50-659">這個欄位的值是冒號 （:） 在 Windows 和 Macintosh 上，與 UNIX 作業系統上的斜線 （/）。</span><span class="sxs-lookup"><span data-stu-id="c2c50-659">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="c2c50-660">這是最適合用來剖析路徑，例如"c:\windows"或 「 MacVolume:System 資料夾 」。</span><span class="sxs-lookup"><span data-stu-id="c2c50-660">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2c50-661">下列範例示範如何使用`VolumeSeparatorChar`欄位。</span><span class="sxs-lookup"><span data-stu-id="c2c50-661">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="c2c50-662">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="c2c50-662">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="c2c50-663">HOW TO：讀取檔案中的文字</span><span class="sxs-lookup"><span data-stu-id="c2c50-663">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="c2c50-664">作法：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="c2c50-664">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>