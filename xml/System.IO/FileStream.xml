<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ef4f5192898fd886f87cb3f256ae8fbf8c30ae1e" /><Meta Name="ms.sourcegitcommit" Value="75eca440f8f4d595506405f48961f38649e160d7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="06/01/2019" /><Meta Name="ms.locfileid" Value="66458039" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>為檔案提供 <see cref="T:System.IO.Stream" />，同時支援同步與非同步讀取和寫入作業。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileStream>類別來讀取、 寫入來開啟和關閉檔案，在檔案系統上，以及操作包括管道、 標準的輸入和標準輸出其他檔案相關的作業系統控制代碼。 您可以使用<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.Stream.CopyTo%2A>，和<xref:System.IO.FileStream.Flush%2A>方法來執行同步作業，或<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>執行非同步方法作業。 使用非同步的方法來執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。 <xref:System.IO.FileStream> 輸入緩衝區和輸出更好的效能。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 <xref:System.IO.FileStream.IsAsync%2A>屬性可讓您偵測是否以非同步方式開啟檔案控制代碼。 當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別的建構函式`isAsync`， `useAsync`，或`options`參數。 若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，<xref:System.IO.FileStream.IsAsync%2A>屬性不一定要`true`來呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 當<xref:System.IO.FileStream.IsAsync%2A>屬性是`false`和您呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業以同步方式執行。  
  
 <xref:System.IO.FileStream.Seek%2A>方法支援隨機存取檔案。 <xref:System.IO.FileStream.Seek%2A> 允許的讀取/寫入位置移到檔案中的任何位置。 這是與位元組位移的參考點參數。 是相對於搜尋參考點，可以是開頭、 目前的位置或基礎檔案中，結尾的三個成員所表示的位元組位移<xref:System.IO.SeekOrigin>列舉型別。  
  
> [!NOTE]
>  磁碟檔案一律會支援隨機存取。 在建構時<xref:System.IO.FileStream.CanSeek%2A>屬性值設定為`true`或`false`取決於基礎檔案類型。如果基礎檔案類型是 FILE_TYPE_DISK，定義 winbase.h，於<xref:System.IO.FileStream.CanSeek%2A>屬性值是`true`。 否則，請<xref:System.IO.FileStream.CanSeek%2A>屬性值是`false`。  
  
 如果處理程序會終止並鎖定檔案的一部分，或關閉具有未完成的鎖定的檔案，則行為會是未定義。  
  
 目錄作業和其他檔案作業，請參閱<xref:System.IO.File>， <xref:System.IO.Directory>，和<xref:System.IO.Path>類別。 <xref:System.IO.File>類別是具有主要是針對建立的靜態方法的公用程式類別<xref:System.IO.FileStream>物件為基礎的檔案路徑。 <xref:System.IO.MemoryStream>類別從位元組陣列建立的資料流，類似於<xref:System.IO.FileStream>類別。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
## <a name="detection-of-stream-position-changes"></a>偵測 Stream 位置變更  
 當<xref:System.IO.FileStream>物件沒有其控制代碼的獨佔的按住不放，另一個執行緒可以同時存取的檔案控制代碼及變更作業系統檔案控制代碼相關聯的檔案指標的位置。 在此情況下，快取的位置中<xref:System.IO.FileStream>物件和快取的緩衝區中的資料可能會外洩。 <xref:System.IO.FileStream>物件會定期執行檢查存取快取的緩衝區，以確保作業系統的控制代碼的位置與快取所使用的位置相同的方法上<xref:System.IO.FileStream>物件。  
  
 如果偵測到的呼叫中的控制代碼的位置中有未預期的變更<xref:System.IO.FileStream.Read%2A>方法中，.NET Framework 會捨棄緩衝區的內容，並再次從檔案讀取資料流。 這可能會影響效能，取決於大小的檔案和任何其他處理程序可能會影響檔案資料流的位置。  
  
 如果偵測到的呼叫中的控制代碼的位置中有未預期的變更<xref:System.IO.FileStream.Write%2A>方法，將緩衝區的內容都會被捨棄和<xref:System.IO.IOException>擲回例外狀況。  
  
 A<xref:System.IO.FileStream>物件並不會獨佔的按住不放上其控制代碼時任一<xref:System.IO.FileStream.SafeFileHandle%2A>公開控制代碼存取屬性或<xref:System.IO.FileStream>物件會得到<xref:System.IO.FileStream.SafeFileHandle%2A>其建構函式中的屬性。  
  
   
  
## Examples  
 下列範例示範一些<xref:System.IO.FileStream>建構函式。  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 下列範例示範如何以非同步方式寫入檔案。 在具有 TextBlock，名為 u 和 連接到名為 Button_Click Click 事件處理常式按鈕的 WPF 應用程式中，執行此程式碼。 檔案路徑必須存在於電腦上的檔案變更。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">如何：讀取和寫入新建立的資料檔案</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <summary>使用指定的讀取/寫入權限，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.IO.Stream.Close%2A>是呼叫，控制代碼，也會關閉和檔案的控制代碼計數會遞減。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <summary>使用指定的讀取/寫入權限，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.IO.Stream.Close%2A>是呼叫，控制代碼，也會關閉和檔案的控制代碼計數會遞減。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <summary>使用指定的路徑和建立模式初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
 建構函式有讀取/寫入權限到檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。  
  
 您無法使用這個建構函式來開啟唯讀檔案;相反地，您必須使用建構函式接受`FileAccess`參數值設為`FileAccess.Read`。  
  
 緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
 建構函式，而不需要<xref:System.IO.FileAccess>參數，如果`mode`參數設為<xref:System.IO.FileMode.Append>，<xref:System.IO.FileAccess.Write>是預設存取權。 否則，將存取設為<xref:System.IO.FileAccess.ReadWrite>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> 會指定唯讀的檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含無效的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 常數，它會設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <summary>使用指定的讀取/寫入權限和緩衝區大小，初始化指定的檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> 參數是無效的控制代碼。  
  
-或- 
<paramref name="handle" /> 參數是同步的控制代碼，且曾以非同步方式使用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 參數為負。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="ownsHandle">如果這個 <see langword="FileStream" /> 執行個體將擁有檔案控制代碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的讀取/寫入權限和 <see cref="T:System.IO.FileStream" /> 執行個體擁有權，初始化指定檔案控制代碼之 <see langword="FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`物件給指定的存取權的檔案。 將會擁有權的控制代碼所指定。 如果此程序擁有的控制代碼，呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉控制代碼，而檔案的控制代碼計數會遞減。 `FileStream`物件會得到預設緩衝區大小為 4096 位元組。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫的方法以外`Close`完成之後使用控制代碼。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果 <paramref name="path" /> 指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <summary>使用指定路徑、建立模式和讀取/寫入權限，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
 建構函式有讀取/寫入權限到檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。 緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含無效的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">這個 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="isAsync">如果控制代碼為非同步開啟 (也就是，在重疊 I/O 模式)，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的讀取/寫入權限、緩衝區大小和同步或非同步狀態，初始化指定的檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您設定`isAsync`參數來`true`以非同步方式開啟檔案控制代碼。 當參數是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，此參數不一定要`true`來呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 當`isAsync`參數是`false`和您呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業以同步方式執行。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> 參數是無效的控制代碼。  
  
-或- 
<paramref name="handle" /> 參數是同步的控制代碼，且曾以非同步方式使用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 參數為負。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">這個 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="ownsHandle">如果這個 <see langword="FileStream" /> 執行個體將擁有檔案控制代碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <summary>使用指定的讀取/寫入權限、<see langword="FileStream" /> 執行個體擁有權和緩衝區大小，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`物件給指定的存取權的檔案。 將會擁有權的控制代碼所指定。 如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉控制代碼。 特別是，檔案的控制碼計數會遞減。 `FileStream`物件有指定的緩衝區大小。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 為負。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果 <paramref name="path" /> 指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理序如何共用檔案。</param>
        <summary>使用指定路徑、建立模式、讀取/寫入權限和共用權限，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
 建構函式有讀取/寫入權限到檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。 緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
系統正在執行 Windows 98 或 Windows 98 Second Edition，而 <paramref name="share" /> 設為 <see langword="FileShare.Delete" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含無效的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">這個 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="ownsHandle">如果這個 <see langword="FileStream" /> 執行個體將擁有檔案控制代碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="isAsync">如果控制代碼為非同步開啟 (也就是，在重疊 I/O 模式)，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的讀取/寫入權限、<see langword="FileStream" /> 執行個體擁有權、緩衝區大小和同步或非同步狀態，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`物件給指定的存取權的檔案。 將會擁有權的控制代碼所指定。 如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉控制代碼。 特別是，檔案的控制碼計數會遞減。 `FileStream`物件有指定的緩衝區大小。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" /> 小於 <see langword="FileAccess.Read" /> 或大於 <see langword="FileAccess.ReadWrite" />，或者 <paramref name="bufferSize" /> 小於或等於 0。</exception>
        <exception cref="T:System.ArgumentException">控制代碼無效。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">作業系統不允許 <paramref name="access" /> 要求用於指定的檔案控制代碼，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設為唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用於存取 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果 <paramref name="path" /> 指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <summary>使用指定路徑、建立模式、讀取/寫入與共用權限與緩衝區大小，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 為負值或零。  
  
-或- 
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
系統正在執行 Windows 98 或 Windows 98 Second Edition，而 <paramref name="share" /> 設為 <see langword="FileShare.Delete" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果 <paramref name="path" /> 指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="useAsync">指定要使用非同步 I/O 或同步 I/O。 但是，請注意：基礎作業系統可能並不支援非同步 I/O，所以在指定 <see langword="true" /> 時，可能會視平台以同步方式開啟控制代碼。 在以非同步方式開啟時，<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 與 <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法對大量讀取或寫入的作業會有較佳的效能，但對於少量讀取和寫入的作業卻會比較慢。 如果要將應用程式設計成使用非同步 I/O，請將 <paramref name="useAsync" /> 參數設定為 <see langword="true" />。 正確地使用非同步 I/O，可以讓應用程式的執行快上十倍，但如果沒有配合非同步 I/O 的需求重新設計應用程式，卻會降低十倍的效能。</param>
        <summary>使用指定路徑、建立模式、讀取/寫入與共用權限、緩衝大小與同步或非同步狀態，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何以非同步方式將資料寫入檔案，然後確認資料已正確地寫入。 A`State`會建立物件來將資訊從主執行緒傳遞`EndReadCallback`和`EndWriteCallback`方法。  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 為負值或零。  
  
-或- 
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
系統正在執行 Windows 98 或 Windows 98 Second Edition，而 <paramref name="share" /> 設為 <see langword="FileShare.Delete" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果 <paramref name="path" /> 指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="options">值，指定其他檔案選項。</param>
        <summary>使用指定的路徑、建立模式、讀取/寫入與共用權限、其他 FileStream 對同一檔案的存取權、緩衝區大小和其他檔案選項，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 `fileOptions`參數用來提供更進階的作業建立時可運用的存取權<xref:System.IO.FileStream>物件。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會將資料寫入至檔案，並接著會讀取資料使用<xref:System.IO.FileStream>物件。  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 為負值或零。  
  
-或- 
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。  
  
-或- 
 針對 <paramref name="options" /> 指定了 <see cref="F:System.IO.FileOptions.Encrypted" />，但目前平台不支援檔案加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see cref="T:System.IO.FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="rights">常數，決定建立檔案的存取和稽核規則時要使用的存取權。</param>
        <param name="share">常數，決定處理序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="options">常數，指定其他檔案選項。</param>
        <summary>使用指定的路徑、建立模式、存取權與共用權限、緩衝區大小和其他檔案選項，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 使用此<xref:System.IO.FileStream.%23ctor%2A>建構函式來套用存取權限時建立檔案的檔案。 若要存取或修改現有的檔案上的權限，請考慮使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 `fileOptions`參數用來提供更進階的作業建立時可運用的存取權<xref:System.IO.FileStream>物件。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 為負值或零。  
  
-或- 
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Windows NT 或更新版本。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。  
  
-或- 
 針對 <paramref name="options" /> 指定了 <see cref="F:System.IO.FileOptions.Encrypted" />，但目前平台不支援檔案加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的 <paramref name="path" />、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see cref="T:System.IO.FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="rights">常數，決定建立檔案的存取和稽核規則時要使用的存取權。</param>
        <param name="share">常數，決定處理序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="options">常數，指定其他檔案選項。</param>
        <param name="fileSecurity">常數，決定檔案的存取控制和稽核安全性。</param>
        <summary>使用指定的路徑、建立模式、存取權與共用權限、緩衝區大小、其他檔案選項、存取控制和稽核安全性，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。  
  
 使用此<xref:System.IO.FileStream.%23ctor%2A>建構函式來套用存取權限時建立檔案的檔案。 若要存取或修改現有的檔案上的權限，請考慮使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 `fileOptions`參數用來提供更進階的作業建立時可運用的存取權<xref:System.IO.FileStream>物件。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。 例如，根據系統中，這個類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會將資料寫入至檔案，並接著會讀取資料使用<xref:System.IO.FileStream>物件。  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
-或- 
 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> 指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> 為負值或零。  
  
-或- 
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案，例如當 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如當 <paramref name="path" /> 指定的檔案已存在時指定 <see langword="FileMode.CreateNew" />。  
  
-或- 
資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定的 <paramref name="path" /> 作業系統不允許 <paramref name="access" /> 要求，例如當 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案或目錄設為唯讀存取時。  
  
-或- 
 針對 <paramref name="options" /> 指定了 <see cref="F:System.IO.FileOptions.Encrypted" />，但目前平台不支援檔案加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的 <paramref name="path" />、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Windows NT 或更新版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取、 寫入和附加至檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">要讀取資料的緩衝區。</param>
        <param name="buffer">To be added.</param>
        <param name="offset">在 <paramref name="array" /> 中要開始讀取的位元組位移。</param>
        <param name="numBytes">要讀取的最大位元組數。</param>
        <param name="count">To be added.</param>
        <param name="callback">在非同步讀取作業完成時所呼叫的方法。</param>
        <param name="userCallback">在非同步讀取作業完成時所呼叫的方法。</param>
        <param name="state">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步讀取的要求。</param>
        <param name="stateObject">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步讀取的要求。</param>
        <summary>開始非同步的讀取作業。 請考慮改用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。</summary>
        <returns>物件，參考非同步讀取。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">陣列長度減去 <paramref name="offset" /> 會小於 <paramref name="numBytes" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="numBytes" /> 是負數。</exception>
        <exception cref="T:System.IO.IOException">在超過檔案結尾處嘗試了非同步讀取。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">包含要寫入目前資料流之資料的緩衝區。</param>
        <param name="buffer">To be added.</param>
        <param name="offset"><paramref name="array" /> 中以零起始的位元組位移，即開始將位元組複製到目前資料流的位置。</param>
        <param name="numBytes">寫入的最大位元組數。</param>
        <param name="count">To be added.</param>
        <param name="callback">在非同步寫入作業完成時所呼叫的方法。</param>
        <param name="userCallback">在非同步寫入作業完成時所呼叫的方法。</param>
        <param name="state">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步寫入的要求。</param>
        <param name="stateObject">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步寫入的要求。</param>
        <summary>開始非同步的寫入作業。 請考慮改用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。</summary>
        <returns>物件，參考非同步寫入。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 長度減去 <paramref name="offset" /> 小於 <paramref name="numBytes" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="numBytes" /> 為負。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前資料流是否支援讀取。</summary>
        <value>如果資料流支援讀取，則為 <see langword="true" />；如果資料流已關閉或以唯寫存取開啟，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類別衍生自<xref:System.IO.Stream>不支援讀取，呼叫<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.ReadByte%2A>，以及<xref:System.IO.FileStream.BeginRead%2A>方法會擲回<xref:System.NotSupportedException>。  
  
 如果資料流已關閉，則這個屬性會傳回`false`。  
  
   
  
## Examples  
 下列範例示範使用`CanRead`屬性。 此程式碼的輸出會是 「 MyFile.txt 不是可寫入。 」 若要取得的輸出訊息"MyFile.txt 可被寫入和讀取。"，變更`FileAccess`參數來`ReadWrite`在`FileStream`建構函式。  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前資料流是否支援搜尋。</summary>
        <value>如果資料流支援搜尋，則為 <see langword="true" />；如果資料流已關閉或如果 <see langword="FileStream" /> 是從作業系統控制代碼 (例如管道或主控台的輸出) 建構，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類別衍生自<xref:System.IO.Stream>不支援搜尋，呼叫<xref:System.IO.FileStream.Length%2A>， <xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Position%2A>，並<xref:System.IO.FileStream.Seek%2A>擲回<xref:System.NotSupportedException>。  
  
 如果資料流已關閉，則這個屬性會傳回`false`。  
  
   
  
## Examples  
 下列範例會使用`CanSeek`檢查資料流是否支援搜尋的屬性。  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前資料流是否支援寫入。</summary>
        <value>如果資料流支援寫入，則為 <see langword="true" />；如果資料流已關閉或以唯讀存取開啟，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類別衍生自<xref:System.IO.Stream>不支援寫入，呼叫<xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.FileStream.BeginWrite%2A>，或<xref:System.IO.FileStream.WriteByte%2A>就會擲回<xref:System.NotSupportedException>。  
  
 如果資料流已關閉，則這個屬性會傳回`false`。  
  
   
  
## Examples  
 下列範例會使用`CanWrite`檢查資料流是否支援寫入的屬性。  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 以下是範例使用`CanWrite`屬性。 此程式碼的輸出會是 MyFile.txt 可寫入。 」 若要取得的輸出訊息"MyFile.txt 可被寫入和讀取。"，變更`FileAccess`參數來`ReadWrite`在`FileStream`建構函式。  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>這個成員會覆寫 <see cref="M:System.IO.Stream.Close" />，您可以在該主題中找到更完整的文件。

關閉目前資料流和釋放與目前資料流相關聯的任何資源 (例如通訊端和檔案控制代碼)。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.IO.FileStream" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 叫用受保護<xref:System.IO.FileStream.Dispose%2A>方法`disposing`參數設為`true`。 <xref:System.Object.Finalize%2A> 叫用<xref:System.IO.FileStream.Dispose%2A>具有`disposing`設定為`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.IO.FileStream> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以被其他物件呼叫多次。 當覆寫<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />小心不要參考先前處置好的呼叫中的物件<see cref="M:System.ComponentModel.Component.Dispose" />。 如需有關如何實作<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />，請參閱 &lt;&lt;c2&gt; [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
如需詳細資訊<see cref="M:System.ComponentModel.Component.Dispose" />並<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">要等候的暫止非同步要求的參考。</param>
        <summary>等候暫止的非同步讀取作業完成。 (請考慮用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</summary>
        <returns>自資料流讀取的位元組數，在 0 和您所要求的位元組數目之間。 在資料流末端資料流只傳回 0，否則，他們應該封鎖直到至少有 1 位元組可用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和更早版本中，您必須使用方法，例如<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>實作非同步檔案作業。 這些方法是中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。  
  
 <xref:System.IO.FileStream.EndRead%2A> 每次呼叫必須剛好呼叫<xref:System.IO.FileStream.BeginRead%2A>。 若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。  
  
 這個方法覆寫 <xref:System.IO.Stream.EndRead%2A>。  
  
 <xref:System.IO.FileStream.EndRead%2A> 可呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginRead%2A>。 呼叫<xref:System.IO.FileStream.EndRead%2A>會告訴您從資料流讀取多少個位元組。 <xref:System.IO.FileStream.EndRead%2A> 將會封鎖直到 I/O 作業完成為止。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">這個 <see cref="T:System.IAsyncResult" /> 物件不是透過對這個類別呼叫 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 所建立。</exception>
        <exception cref="T:System.InvalidOperationException">多次呼叫 <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.IO.IOException">資料流已關閉或發生內部錯誤。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">非同步檔案 I/O</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">暫止的非同步 I/O 要求。</param>
        <summary>結束非同步寫入作業並封鎖，直到 I/O 作業完成。 (請考慮用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和更早版本中，您必須使用方法，例如<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>實作非同步檔案作業。 這些方法是中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。  
  
 這個方法覆寫 <xref:System.IO.Stream.EndWrite%2A>。  
  
 <xref:System.IO.FileStream.EndWrite%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginWrite%2A>。 <xref:System.IO.FileStream.EndWrite%2A> 將會封鎖直到 I/O 作業完成為止。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">這個 <see cref="T:System.IAsyncResult" /> 物件不是透過對這個類別呼叫 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 所建立。</exception>
        <exception cref="T:System.InvalidOperationException">多次呼叫 <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.IO.IOException">資料流已關閉或發生內部錯誤。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">非同步檔案 I/O</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認釋出資源，並在記憶體回收行程再利用 <see langword="FileStream" /> 時執行其他清除作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 記憶體回收行程呼叫`Finalize`時準備好完成目前的物件。 `Finalize` 關閉`FileStream`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>。  
  
 當您呼叫<xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType>作業系統 I/O 緩衝區的方法，也會排清。  
  
 除非您明確地呼叫未排清資料流編碼器<xref:System.IO.FileStream.Flush%2A>或處置物件。 設定<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>至`true`表示資料會從排清緩衝區資料流，但並不會清除編碼器的狀態。 這可讓編碼器，讓它可以正確編碼字元的下一個區塊保持其狀態 （部分的字元）。 UTF8，UTF7，其中某些字元可以只編碼編碼器接收或多個相鄰的字元後，會影響此案例。  
  
 因為緩衝區可供讀取或寫入，<xref:System.IO.FileStream.Flush>會執行下列兩個函式：  
  
-   任何先前寫入緩衝區的資料複製到檔案，除了其編碼器狀態清除緩衝區。  
  
-   如果<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType>是`true`資料先前已從檔案複製到讀取的緩衝區，檔案中目前的位置也會減少在緩衝區中未讀取的位元組數目。 然後清除緩衝區。  
  
 使用<xref:System.IO.FileStream.Flush%28System.Boolean%29>方法多載時您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" /> 表示排清所有中繼檔案緩衝區；否則為 <see langword="false" />。</param>
        <summary>清除此資料流的緩衝區，讓所有緩衝資料全部寫入檔案，同時也清除所有的中繼檔案緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。  
  
 當您呼叫<xref:System.IO.FileStream.Flush%2A>作業系統 I/O 緩衝區的方法，也會排清。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">用來監視是否有取消要求的語彙基元。</param>
        <summary>以非同步的方式清除這個資料流的所有緩衝區，造成所有緩衝資料都寫入基礎裝置，並且監視取消要求。</summary>
        <returns>表示非同步排清作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。 如果已處置之檔案的控制代碼，傳回的工作會包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">資料流已經處置。</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">取消</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件會封裝目前 <see cref="T:System.IO.FileStream" /> 物件所描述的檔案之存取控制清單 (ACL) 項目。</summary>
        <returns>封裝目前 <see cref="T:System.IO.FileStream" /> 物件所描述檔案之存取控制設定的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然<xref:System.IO.FileStream>類別以及<xref:System.IO.FileStream.GetAccessControl%2A>可用來擷取現有的檔案的存取控制清單 (ACL) 項目，請考慮使用<xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType>方法，因為它比較容易使用。  
  
 使用<xref:System.IO.FileStream.GetAccessControl%2A>方法來擷取檔案的 ACL 項目。  
  
 ACL 描述個人及/或群組，或沒有，在指定的檔案上的特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.SystemException">找不到檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">這個作業在目前平台不受支援。  
  
-或- 
呼叫端沒有必要的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see langword="FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼。</summary>
        <value>這個 <see langword="FileStream" /> 物件所封裝的檔案之作業系統檔案控制代碼；如果 <see langword="FileStream" /> 已關閉，則為 -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是用於操作-系統提供的系統呼叫作業系統控制代碼 (例如`ReadFile`在 Windows 上)。 不適用於 C 程式庫函式預期的檔案描述項，例如`fread`。  
  
 作業系統控制代碼可能已經開啟同步或非同步的方式，依據`FileStream`呼叫建構函式。 使用<xref:System.IO.FileStream.IsAsync%2A>屬性探索是否以非同步方式開啟此控制代碼。 在 Win32 中，這表示重疊 IO 的開啟控制代碼，而且需要不同的參數，來`ReadFile`和`WriteFile`。  
  
> [!CAUTION]
>  如果，可能會發生資料損毀`FileStream`會建立，其控制代碼傳遞、 某項作業移動控制代碼的檔案指標，然後`FileStream`會再次使用。 多個執行緒無法安全地寫入相同的檔案，同時並`FileStream`緩衝處理程式碼會假設它以獨佔方式控制控制代碼。 `FileStream` 可能會擲回<xref:System.IO.IOException>如果`FileStream`偵測到某些其他處理序已移動檔案指標。 若要避免這個問題，不寫入任何資料到檔案的一部分，`FileStream`可能會有經過緩衝處理，並將檔案指標還原上一次上呼叫方法時發生的位置`FileStream`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供存取 unmanaged 程式碼的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see langword="FileStream" /> 是以非同步或同步方式開啟。</summary>
        <value>如果 <see langword="FileStream" /> 是非同步開啟，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsAsync`屬性會偵測是否`FileStream`控制代碼已啟用程式碼以使用以非同步方式開啟<xref:System.IO.FileStream.Handle%2A>屬性正確。 在 Win32 中，`IsAsync`正在 true 表示控制代碼已針對重疊 I/O 開啟，並因此需要不同的參數，才能`ReadFile`和`WriteFile`。  
  
 當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別的建構函式`isAsync`， `useAsync`，或`options`參數。 若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，<xref:System.IO.FileStream.IsAsync%2A>屬性不一定要`true`來呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 當<xref:System.IO.FileStream.IsAsync%2A>屬性是`false`和您呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業以同步方式執行。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得資料流的位元組長度。</summary>
        <value>代表資料流長度的長數值 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會使用`Length`和`Position`屬性來檢查檔案結尾條件。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個資料流的 <see cref="P:System.IO.FileStream.CanSeek" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如檔案已關閉。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">鎖定的範圍開頭。 這個參數的值必須等於或大於零 (0)。</param>
        <param name="length">要鎖定的範圍。</param>
        <summary>防止其他處理程序讀取或寫入 <see cref="T:System.IO.FileStream" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鎖定某個範圍的檔案資料流可讓該範圍的檔案資料流的鎖定處理程序的獨佔存取權的執行緒。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定檔案的一部分，讓另一個處理序無法存取該檔案的一部分，即使它具有讀取/寫入檔案存取權。 在不同的命令視窗中，同時執行程式，並調查使用不同的主控台輸入的選項。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> 或 <paramref name="length" /> 為負。</exception>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.IO.IOException">處理序無法存取檔案，因為其他處理序鎖定了該檔案的一部分。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在 <see langword="FileStream" /> 中開啟之檔案的絕對路徑。</summary>
        <value>為檔案的絕對路徑的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

如果不知道的絕對路徑，這個屬性會傳回字串，類似於 「 [不明] 」。

 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個資料流的目前位置。</summary>
        <value>這個資料流的目前位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援搜尋超過資料流長度的任何位置。  當您尋找檔案的長度超過檔案大小將會成長。  在 Microsoft Windows NT 及更新版本，任何新增至檔案結尾的資料是設定為零。  在 Microsoft Windows 98 或更早版本，任何新增至檔案結尾的資料不會設定為零，表示先前已刪除的資料會顯示資料流。 將資料流的位置設定為較大的值，在 Windows 98 或更早版本的資料流結尾以外的位置，可能會導致引發例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會使用`Length`和`Position`屬性來檢查檔案結尾條件。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">資料流不支援搜尋。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。  
  
-或- 
位置設為非常大的值，超出 Windows 98 或更早版本的資料流結尾。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">嘗試將位置設為負數值。</exception>
        <exception cref="T:System.IO.EndOfStreamException">嘗試搜尋超過資料流的結尾，但不支援此作業。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="fileStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">當這個方法傳回時，會包含指定的位元組陣列，這個陣列具有介於 <paramref name="offset" /> 到 (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c> 之間的值，已由讀取自目前來源的位元組所取代。</param>
        <param name="offset">要在其中放置讀取位元組之 <paramref name="array" /> 的位元組位移。</param>
        <param name="count">要讀取的最大位元組數。</param>
        <summary>從資料流讀取位元組區塊，並將資料寫入指定緩衝區。</summary>
        <returns>緩衝區所讀取的總位元組數。 如果目前無法提供那麼多的位元組數目，則這個數目可能小於所要求的位元組數；如果已經到達資料流末端，則為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Read%2A>。  
  
 `offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始讀取，而`count`參數會提供要從這個資料流讀取的位元組數目上限。 如果已到達資料流結尾，傳回的值會是位元組讀取，則為零的實際數目。 讀取的作業成功時，讀取的位元組數目進階資料流的目前位置。 如果發生例外狀況，資料流的目前位置不變。  
  
 <xref:System.IO.FileStream.Read%2A>方法會傳回零，只有在到達資料流結尾之後。 否則，<xref:System.IO.FileStream.Read%2A>一律從資料流讀取至少一個位元組，再傳回。 沒有資料是否可用，從呼叫時，資料流<xref:System.IO.FileStream.Read%2A>，此方法將會封鎖直到至少一個位元組的資料可以傳回。 實作可以自由地傳回比要求更少個位元組，即使尚未達到資料流結尾。  
  
 使用<xref:System.IO.BinaryReader>讀取基本資料型別。  
  
 不會中斷正在執行讀取的作業的執行緒。 雖然應用程式可能會出現以解除封鎖的執行緒之後，請執行成功，您的應用程式效能和可靠性，就可能會降低中斷時間。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會讀取來自的內容<xref:System.IO.FileStream>並將它寫入至另一個<xref:System.IO.FileStream>。  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援讀取。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的無效範圍。</exception>
        <exception cref="T:System.ObjectDisposedException">關閉資料流後呼叫了方法。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入資料的緩衝區。</param>
        <param name="offset">開始於此處自資料流寫入資料的 <paramref name="buffer" /> 中的位元組位移。</param>
        <param name="count">要讀取的最大位元組數。</param>
        <param name="cancellationToken">用來監視是否有取消要求的語彙基元。</param>
        <summary>以非同步的方式從目前資料流讀取一連串的位元組、依所讀取的位元組數目進階資料流中的位置，以及監視取消要求。</summary>
        <returns>表示非同步讀取作業的工作。 <paramref name="TResult" /> 參數的值會包含讀取至緩衝區的位元組總數。 如果目前可供使用的位元組數目少於所要求的數目，結果值可能會小於所要求的位元組數目，或者如果已經到達資料流末端，則可能為 0 (零)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.ReadAsync%2A>方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。 非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。  
  
 使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。  
  
 如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。 如果已處置之檔案的控制代碼，傳回的工作會包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。  
  
   
  
## Examples  
 下列範例示範如何以非同步方式從檔案讀取。  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援讀取。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已經處置。</exception>
        <exception cref="T:System.InvalidOperationException">之前的讀取作業目前正在使用資料流。</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">取消</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從檔案讀取一個位元組，並將讀取位置前移一個位元組。</summary>
        <returns>轉換為 <see cref="T:System.Int32" /> 的位元組，如果已經到達資料流的末端，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.ReadByte%2A>。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanRead%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前的資料流不支援讀取。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的資料流已關閉。</exception>
        <block subset="none" type="overrides"><para>上的預設實作<see langword="Stream" />建立新的單一位元組陣列，然後呼叫<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />。 雖然這是正式正確，但卻效率不佳。 任何具有內部緩衝區的資料流應該覆寫這個方法，並提供更有效率的版本直接讀取緩衝區，避免在每次呼叫配置額外的陣列。  
  
如需常見的檔案和目錄作業的清單，請參閱 &lt;&lt;c0&gt; [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 物件，這個物件代表目前的 <see cref="T:System.IO.FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼。</summary>
        <value>代表目前 <see cref="T:System.IO.FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A>屬性自動清除資料流，並將目前的資料流位置設為 0。  這可讓要移動檔案或另一個資料流使用重設資料流位置<xref:System.IO.FileStream.SafeFileHandle%2A>這個屬性傳回。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼的權限。  
  
安全性動作：連結要求 
相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">相對於 <paramref name="origin" /> 的搜尋起點。</param>
        <param name="origin">使用 <paramref name="offset" /> 類型的值，指定開頭、結尾或目前位置做為 <see cref="T:System.IO.SeekOrigin" /> 的參考點。</param>
        <summary>設定這個資料流的目前位置為指定的數值。</summary>
        <returns>資料流中的新位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType>屬性來判斷目前的執行個體是否支援搜尋。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>。  
  
 您可以搜尋超過資料流長度的任何位置。 當您尋找檔案的長度超過檔案大小將會成長。 在 Windows NT 和更新版本中，新增至檔案結尾的資料是設定為零。 在 Windows 98 或更早版本中，新增至檔案結尾的資料未設定為零，表示先前已刪除的資料會顯示資料流。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 下列範例會使用各種檔案結尾開頭的檔案，請從讀取文字方向會相反，<xref:System.IO.SeekOrigin>值與<xref:System.IO.FileStream.Seek%2A>方法。  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援搜尋，例如如果 <see langword="FileStream" /> 是從管道或主控台輸出所建構。</exception>
        <exception cref="T:System.ArgumentException">在資料流開始之前嘗試搜尋。</exception>
        <exception cref="T:System.ObjectDisposedException">關閉資料流後呼叫了方法。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">物件，描述要套用至目前檔案的 ACL 項目。</param>
        <summary>將 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件所描述的存取控制清單 (ACL) 項目套用至目前 <see cref="T:System.IO.FileStream" /> 物件所描述的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然<xref:System.IO.FileStream>類別以及<xref:System.IO.FileStream.SetAccessControl%2A>可以用在現有的檔案，請考慮使用<xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType>方法，因為它比較容易使用。  
  
 <xref:System.IO.FileStream.SetAccessControl%2A>方法適用於存取控制清單 (ACL) 項目代表 noninherited 的 ACL 清單的檔案。  
  
> [!CAUTION]
>  指定 ACL`fileSecurity`參數已取代現有檔案的 ACL。 若要新增之新使用者的權限，請使用<xref:System.IO.FileStream.GetAccessControl%2A>方法，以取得現有的 ACL，修改它，然後再使用<xref:System.IO.FileStream.SetAccessControl%2A>套用回到檔案。  
  
 ACL 描述個人及/或群組，或沒有，在指定的檔案上的特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileSecurity" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">找不到或無法修改檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">目前的處理序不具有開啟檔案的存取權。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">資料流的新長度。</param>
        <summary>設定這個資料流長度為指定的數值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.SetLength%2A>。  
  
 如果指定的值小於目前資料流的長度，則會截斷資料流。 在此案例中，目前位置是否大於新的長度，目前位置移到資料流的最後一個位元組。 如果指定的值大於目前的資料流的長度，展開 資料流時，和目前的位置維持不變。 如果資料流已展開，舊和新的長度之間的資料流的內容為未定義。  
  
 資料流必須支援寫入和搜尋的`SetLength`運作。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入，而<xref:System.IO.FileStream.CanSeek%2A>屬性來判斷是否支援搜尋。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A> 和 <xref:System.IO.Stream.CanSeek%2A>。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入和搜尋。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">已嘗試將 <paramref name="value" /> 參數設定為小於 0。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">解除鎖定範圍的開頭。</param>
        <param name="length">要解除鎖定的範圍。</param>
        <summary>允許其他處理序存取先前鎖定之檔案的全部或一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定檔案的一部分，因此無法存取該檔案的一部分，即使它具有讀取/寫入檔案存取權，另一個處理序，並將其再解除鎖定指定的組件的檔案。 在不同的命令視窗中，同時執行程式，並調查使用不同的主控台輸入的選項。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> 或 <paramref name="length" /> 為負。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="fileStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">包含要寫入資料流之資料的緩衝區。</param>
        <param name="offset"><paramref name="array" /> 中以零起始的位元組位移，要從其中開始將位元組複製至資料流。</param>
        <param name="count">寫入的最大位元組數。</param>
        <summary>將位元組區塊寫入檔案資料流中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Write%2A>。  
  
 `offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始複製，而`count`參數會提供將寫入資料流的位元組數目。 如果寫入作業成功，寫入的位元組數目進階資料流的目前位置。 如果發生例外狀況，資料流的目前位置不變。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A>。  
  
 不會中斷正在執行寫入作業的執行緒。 雖然應用程式可能會出現以解除封鎖的執行緒之後，請執行成功，您的應用程式效能和可靠性，就可能會降低中斷時間。  
  
 如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的無效範圍。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。  
  
-或- 
另一個執行緒可能會在作業系統之檔案控制代碼的位置，造成未預期的變更。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <exception cref="T:System.NotSupportedException">目前的資料流執行個體不支援寫入。</exception>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入資料的來源緩衝區。</param>
        <param name="offset"><paramref name="buffer" /> 中以零起始的位元組位移，要從其中開始將位元組複製至資料流。</param>
        <param name="count">寫入的最大位元組數。</param>
        <param name="cancellationToken">用來監視是否有取消要求的語彙基元。</param>
        <summary>以非同步的方式將一連串的位元組寫入目前的資料流，由這個資料流中目前的位置前移寫入的位元組數目，並且監視取消要求。</summary>
        <returns>表示非同步寫入作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.WriteAsync%2A>方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。 非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。  
  
 使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。  
  
 如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。 如果已處置之檔案的控制代碼，傳回的工作會包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。  
  
   
  
## Examples  
 下列範例示範如何以非同步方式寫入檔案。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已經處置。</exception>
        <exception cref="T:System.InvalidOperationException">之前的寫入作業目前正在使用資料流。</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">取消</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要寫入資料流的位元組。</param>
        <summary>寫入一個位元組到檔案資料流中的目前位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.WriteByte%2A>。  
  
 使用`WriteByte`寫入一個位元組來`FileStream`有效率的方式。 如果已關閉或無法寫入資料流，就會擲回例外狀況。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入。</exception>
        <block subset="none" type="overrides"><para>上的預設實作<see langword="Stream" />建立新的單一位元組陣列，然後呼叫<see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。 雖然這是正式正確，但卻效率不佳。 任何具有內部緩衝區的資料流應該覆寫這個方法，並提供更有效率的版本直接讀取緩衝區，避免在每次呼叫配置額外的陣列。  
  
如需常見的檔案和目錄作業的清單，請參閱 &lt;&lt;c0&gt; [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">檔案和資料流 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">如何：從檔案讀取文字</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">如何：將文字寫入檔案</related>
      </Docs>
    </Member>
  </Members>
</Type>
