<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f948c10a6f9c08faf0d5a6141f3daaa6c9d718c3" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58453512" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="5c8dc-101">中的項目類型<see cref="System.Span`1" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-101">The type of items in the <see cref="System.Span`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="5c8dc-102">提供任意記憶體之連續區域的型別和記憶體安全表示。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-102">Provides a type- and memory-safe representation of a contiguous region of arbitrary memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-103">`Span<T>` 已[ref struct](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types)配置堆疊上，而不是 managed 堆積上。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-103">`Span<T>` is a [ref struct](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) that is allocated on the stack rather than on the managed heap.</span></span> <span data-ttu-id="5c8dc-104">Ref 結構類型有一些限制，以確保它們無法提升至受控堆積，包括無法 box 處理，他們無法指派給變數的型別<xref:System.Object>，`dynamic`成任何介面類型，也不能是中的欄位參考型別，而且它們不能跨`await`和`yield`界限。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed, they can't be assigned to variables of type <xref:System.Object>, `dynamic` or to any interface type, they can't be fields in a reference type, and they can't be used across `await` and `yield` boundaries.</span></span> <span data-ttu-id="5c8dc-105">此外，兩個方法，會呼叫<xref:System.Span%601.Equals(System.Object)>並<xref:System.Span%601.GetHashCode%2A>，會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-105">In addition, calls to two methods, <xref:System.Span%601.Equals(System.Object)> and <xref:System.Span%601.GetHashCode%2A>, throw a <xref:System.NotSupportedException>.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="5c8dc-106">因為它是僅限堆疊的型別，`Span<T>`不適合許多情況下，需要儲存在堆積上的緩衝區的參考。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-106">Because it is a stack-only type, `Span<T>` is unsuitable for many scenarios that require storing references to buffers on the heap.</span></span> <span data-ttu-id="5c8dc-107">這是如此，比方說，進行 asynchrous 方法呼叫的常式。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-107">This is true, for example, of routines that make asynchrous method calls.</span></span> <span data-ttu-id="5c8dc-108">對於這類情況中，您可以使用免費<xref:System.Memory%601?displayProperty=nameWithType>和<xref:System.ReadOnlyMemory%601?displayProperty=nameWithType>型別。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-108">For such scenarios, you can use the complimentary <xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> types.</span></span>

<span data-ttu-id="5c8dc-109">代表不可變或唯讀結構的 span，對於使用<xref:System.ReadOnlySpan%601?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-109">For spans that represent immutable or read-only structures, use <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.</span></span>

## <a name="spant-and-memory"></a><span data-ttu-id="5c8dc-110">範圍\<T > 和記憶體</span><span class="sxs-lookup"><span data-stu-id="5c8dc-110">Span\<T> and memory</span></span>

<span data-ttu-id="5c8dc-111">A`Span<T>`代表任意記憶體中的連續區域。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-111">A `Span<T>` represents a contiguous region of arbitrary memory.</span></span> <span data-ttu-id="5c8dc-112">A`Span<T>`執行個體通常用來保存的項目陣列的一部分。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-112">A `Span<T>` instance is often used to hold the elements of an array or a portion of an array.</span></span> <span data-ttu-id="5c8dc-113">不同於陣列，不過，`Span<T>`執行個體可以指向受管理的記憶體，原生記憶體，或在受管理的記憶體堆疊。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-113">Unlike an array, however, a `Span<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span> <span data-ttu-id="5c8dc-114">下列範例會建立`Span<Byte>`從陣列：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-114">The following example creates a `Span<Byte>` from an array:</span></span>

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
<span data-ttu-id="5c8dc-115">下列範例會建立`Span<Byte>`從 100 個位元組的原生記憶體：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-115">The following example creates a `Span<Byte>` from 100 bytes of native memory:</span></span>

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

<span data-ttu-id="5c8dc-116">下列範例會使用C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md)關鍵字可配置的記憶體堆疊上的 100 個位元組：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-116">The following example uses the C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) keyword to allocate 100 bytes of memory on the stack:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

<span data-ttu-id="5c8dc-117">因為`Span<T>`是任意的記憶體區塊，方法的抽象概念`Span<T>`類別和方法`Span<T>`參數對任何`Span<T>`物件，不論其封裝的記憶體的類型。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-117">Because `Span<T>` is an abstraction over an arbitrary block of memory, methods of the `Span<T>` class and methods with `Span<T>` parameters operate on any `Span<T>` object regardless of the kind of memory it encapsulates.</span></span> <span data-ttu-id="5c8dc-118">例如，每個程式碼中的個別區段，用來初始化範圍及計算其項目的總和可以變更為單一的初始設定和計算方法，如下列範例說明：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-118">For example, each of the separate sections of code that initialize the span and calculate the sum of its elements can be changed into single initialization and calculation methods, as the following example illustrates:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a><span data-ttu-id="5c8dc-119">範圍\<T > 和陣列</span><span class="sxs-lookup"><span data-stu-id="5c8dc-119">Span\<T> and arrays</span></span>

<span data-ttu-id="5c8dc-120">它會包裝在陣列中，當`Span<T>`可以包裝整個陣列中的範例中所顯示的一樣[範圍\<T > 和記憶體](#spant-and-memory)區段。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-120">When it wraps an array, `Span<T>` can wrap an entire array, as it did in the examples in the [Span\<T> and memory](#spant-and-memory) section.</span></span> <span data-ttu-id="5c8dc-121">因為它支援切割，`Span<T>`也可以指向任何陣列中的連續範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-121">Because it supports slicing, `Span<T>` can also point to any contiguous range within the array.</span></span>  

<span data-ttu-id="5c8dc-122">下列範例會建立 10 個元素的整數陣列的中間的五個項目之配量。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-122">The following example creates a slice of the middle five elements of a 10-element integer array.</span></span> <span data-ttu-id="5c8dc-123">請注意程式碼會加倍的配量中的每個整數值。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-123">Note that the code doubles the values of each integer in the slice.</span></span> <span data-ttu-id="5c8dc-124">如輸出所示，範圍所做的變更會反映在陣列的值。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-124">As the output shows, the changes made by the span are reflected in the values of the array.</span></span>

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a><span data-ttu-id="5c8dc-125">範圍\<T > 和配量</span><span class="sxs-lookup"><span data-stu-id="5c8dc-125">Span\<T> and slices</span></span>

<span data-ttu-id="5c8dc-126">`Span<T>` 包含兩個多載<xref:System.Span%601.Slice%2A>形成配量超出指定的索引開始的目前範圍的方法。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-126">`Span<T>` includes two overloads of the <xref:System.Span%601.Slice%2A> method that form a slice out of the current span that starts at a specified index.</span></span> <span data-ttu-id="5c8dc-127">如此可讓您將在資料`Span<T>`做為一組可處理視資料處理管線，其中含有最少的效能影響的部分邏輯區塊。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-127">This makes it possible to treat the data in a `Span<T>` as a set of logical chunks that can be processed as needed by portions of a data processing pipeline with minimal performance impact.</span></span> <span data-ttu-id="5c8dc-128">例如，由於新式伺服器通訊協定通常是以文字為基礎，操作字串和子字串是特別重要。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-128">For example, since modern server protocols are often text-based, manipulation of strings and substrings is particularly important.</span></span> <span data-ttu-id="5c8dc-129">在 <xref:System.String>類別的主要方法擷取子字串是<xref:System.String.Substring%2A>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-129">In the <xref:System.String> class, the major method for extracting substrings is <xref:System.String.Substring%2A>.</span></span> <span data-ttu-id="5c8dc-130">針對依賴廣泛的字串操作的資料管線，其使用會提供一些效能的負面影響，因為它：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-130">For data pipelines that rely on extensive string manipulation, its use offers some performance penalties, since it:</span></span>

1. <span data-ttu-id="5c8dc-131">建立新的字串，用來保存子字串。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-131">Creates a new string to hold the substring.</span></span>

2. <span data-ttu-id="5c8dc-132">原始字串一部分的字元複製到新的字串。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-132">Copies a subset of the characters from the original string to the new string.</span></span>

<span data-ttu-id="5c8dc-133">要消除這項配置和複製作業，請使用`Span<T>`或<xref:System.ReadOnlySpan%601>，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-133">This allocation and copy operation can be eliminated by using either `Span<T>` or <xref:System.ReadOnlySpan%601>, as the following example shows:</span></span>

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="5c8dc-134">要從中建立 <see cref="T:System.Span`1" /> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-134">The array from which to create the <see cref="T:System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="5c8dc-135">在整個指定的陣列上建立新的 <see cref="T:System.Span`1" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-135">Creates a new <see cref="T:System.Span`1" /> object over the entirety of a specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-136">如果`array`已`null`，這個建構函式會傳回`null` `Span<T>`。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-136">If `array` is `null`, this constructor returns a `null` `Span<T>`.</span></span>

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException"><span data-ttu-id="5c8dc-137"><paramref name="T" /> 是參考型別，且 <paramref name="array" /> 不是 <paramref name="T" /> 型別的陣列。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-137"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="5c8dc-138">記憶體中指定位元組數目的起始位址指標。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-138">A pointer to the starting address of a specified number of bytes in memory.</span></span></param>
        <param name="length"><span data-ttu-id="5c8dc-139">要包含在 <see cref="T:System.Span`1" /> 中的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-139">The number of bytes to be included in the <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="5c8dc-140">從指定的位元組數目建立新的 <see cref="T:System.Span`1" /> 物件，從指定的記憶體位址開始。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-140">Creates a new <see cref="T:System.Span`1" /> object  from a specified number of bytes starting at a specified memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5c8dc-141"><paramref name="T" /> 是參考型別或包含指標，因此無法儲存在非受控記憶體中。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-141"><paramref name="T" /> is a reference type or contains pointers and therefore cannot be stored in unmanaged memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5c8dc-142"><paramref name="length" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-142"><paramref name="length" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="start" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="5c8dc-143">來源陣列。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-143">The source array.</span></span></param>
        <param name="start"><span data-ttu-id="5c8dc-144">要包含在新的 <see cref="T:System.Span`1" /> 中之第一個項目的索引。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-144">The index of the first element to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <param name="length"><span data-ttu-id="5c8dc-145">要包含在新的 <see cref="T:System.Span`1" /> 中的項目數。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-145">The number of elements to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="5c8dc-146">建立新的 <see cref="T:System.Span`1" /> 物件，其中包含起始於指定索引之陣列的指定項目數。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-146">Creates a new <see cref="T:System.Span`1" /> object that includes a specified number of elements of an array starting at a specified index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5c8dc-147"><paramref name="array" /> 為 <see langword="null" />，但 <paramref name="start" /> 或 <paramref name="length" /> 為非零。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-147"><paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span></span>

<span data-ttu-id="5c8dc-148">-或-</span><span class="sxs-lookup"><span data-stu-id="5c8dc-148">-or-</span></span>

<span data-ttu-id="5c8dc-149"><paramref name="start" /> 在陣列的界限之外。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-149"><paramref name="start" /> is outside the bounds of the array.</span></span>

<span data-ttu-id="5c8dc-150">-或-</span><span class="sxs-lookup"><span data-stu-id="5c8dc-150">-or-</span></span>

<span data-ttu-id="5c8dc-151"><paramref name="start" /> 和 <paramref name="length" /> 超過陣列中的項目數。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-151"><paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span></span></exception>
        <exception cref="T:System.TypeMismatchException"><span data-ttu-id="5c8dc-152"><paramref name="T" /> 是參考型別，且 <paramref name="array" /> 不是 <paramref name="T" /> 型別的陣列。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-152"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5c8dc-153">清除這個 <see cref="T:System.Span`1" /> 物件的內容。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-153">Clears the contents of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-154">`Clear`方法設定的項目<xref:System.Span%601>設為預設值的物件。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-154">The `Clear` method sets the items in the <xref:System.Span%601> object to their default values.</span></span> <span data-ttu-id="5c8dc-155">它不會移除項目從<xref:System.Span%601>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-155">It does not remove items from the <xref:System.Span%601>.</span></span>  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="5c8dc-156">目的地 <see cref="System.Span`1" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-156">The destination <see cref="System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="5c8dc-157">將這個 <see cref="System.Span`1" /> 的內容複製到目的地 <see cref="System.Span`1" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-157">Copies the contents of this <see cref="System.Span`1" /> into a destination <see cref="System.Span`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-158">這個方法會複製所有`source`要`destination`即使`source`和`destination`重疊。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-158">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5c8dc-159"><paramref name="destination" /> 比來源 <see cref="System.Span`1" /> 短。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-159"><paramref name="destination" /> is shorter than the source <see cref="System.Span`1" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c8dc-160">傳回空的 <see cref="T:System.Span`1" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-160">Returns an empty <see cref="T:System.Span`1" /> object.</span></span></summary>
        <value><span data-ttu-id="5c8dc-161">空的 <see cref="T:System.Span`1" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-161">An empty <see cref="T:System.Span`1" /> object.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="5c8dc-162">不支援。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-162">Not supported.</span></span></param>
        <summary><span data-ttu-id="5c8dc-163">不支援呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-163">Calls to this method are not supported.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-164">不支援呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-164">Calls to this method are not supported.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="5c8dc-165">呼叫<xref:System.Span%601.Equals%2A>不支援的方法。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-165">Calls to the <xref:System.Span%601.Equals%2A> method are not supported.</span></span> <span data-ttu-id="5c8dc-166">呼叫<xref:System.Span%601.Equals%2A>方法會產生兩個結果的其中一個：</span><span class="sxs-lookup"><span data-stu-id="5c8dc-166">Calls to the <xref:System.Span%601.Equals%2A> methods produce either of two results:</span></span>

- <span data-ttu-id="5c8dc-167">如果`obj`是<xref:System.Span%601>，方法呼叫會產生編譯器錯誤 CS1503: 「 無法從轉換 'System.Span' 為 'object'。 」這是因為<xref:System.Span%601>已[ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type)無法 box 處理，因此無法轉換成<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-167">If `obj` is a <xref:System.Span%601>, the method call generates compiler error CS1503: "cannot convert from 'System.Span' to 'object'." This is because <xref:System.Span%601> is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that cannot be boxed and therefore cannot be converted to an <xref:System.Object>.</span></span>

- <span data-ttu-id="5c8dc-168">如果類型`obj`不是<xref:System.Span%601>，方法呼叫會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-168">If the type of `obj` is not a <xref:System.Span%601>, the method call throws a <xref:System.NotSupportedException>.</span></span> 

<span data-ttu-id="5c8dc-169">若要比較兩個<xref:System.Span%601>物件是否相等，會使用<xref:System.Span%601.op_Equality%2A>比較運算子。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-169">To compare two <xref:System.Span%601> objects for equality, use the <xref:System.Span%601.op_Equality%2A> comparison operator.</span></span>

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5c8dc-170">不支援呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-170">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5c8dc-171">要指派給範圍之每個項目的值。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-171">The value to assign to each element of the span.</span></span></param>
        <summary><span data-ttu-id="5c8dc-172">以指定的值填入這個範圍的項目。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-172">Fills the elements of this span with a specified value.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5c8dc-173">傳回這個 <see cref="T:System.Span`1" /> 的列舉值。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-173">Returns an enumerator for this <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-174">這個範圍的列舉值。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-174">An enumerator for this span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="5c8dc-175">而不是呼叫<xref:System.Span%601.GetEnumerator%2A>方法直接，您可以使用 C#`foreach`陳述式和 Visual Basic `For Each`...`Next`建構函式來列舉<xref:System.Span%601>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-175">Instead of calling the <xref:System.Span%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.Span%601>.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5c8dc-176">擲回 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-176">Throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-177">呼叫這個方法一律會擲回 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-177">Calls to this method always throw a <see cref="T:System.NotSupportedException" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5c8dc-178">不支援呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-178">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5c8dc-179">傳回索引位置為零之 <see cref="T:System.Span`1" /> 的項目參考。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-179">Returns a reference to the element of the <see cref="T:System.Span`1" /> at index zero.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-180">索引位置為零之 <see cref="T:System.Span`1" /> 的項目參考；如果 <see cref="M:System.Span`1.IsEmpty" /> 為 <see langword="true" />，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-180">A reference to the element of the <see cref="T:System.Span`1" /> at index zero, or <see langword="null" /> if <see cref="M:System.Span`1.IsEmpty" /> is  <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-181">`GetPinnableReference`方法會傳回[ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type)。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-181">The `GetPinnableReference` method returns a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span></span> <span data-ttu-id="5c8dc-182">它可以用於釘選<xref:System.Span%601>在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-182">It can be used for pinning a <xref:System.Span%601> in memory.</span></span> <span data-ttu-id="5c8dc-183">它，才能支援使用<xref:System.Span%601>內[修正](~/docs/csharp/language-reference/keywords/fixed-statement.md)陳述式。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-183">It is required to support the use of a <xref:System.Span%601> within a [fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md) statement.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c8dc-184">傳回值，指出目前的 <see cref="T:System.Span`1" /> 是否為空白。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-184">Returns a value that indicates whether the current <see cref="T:System.Span`1" /> is empty.</span></span></summary>
        <value><span data-ttu-id="5c8dc-185"><see langword="true" /> 如果目前的範圍是空的。否則， <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-185"><see langword="true" /> if the current span is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Index) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[Index] { T % get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Item(Index) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="5c8dc-186">項目之以零為起始的索引。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-186">The zero-based index of the element.</span></span></param>
        <summary><span data-ttu-id="5c8dc-187">取得位於指定索引的元素，該索引以零起始。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-187">Gets the element at the specified zero-based index.</span></span></summary>
        <value><span data-ttu-id="5c8dc-188">在指定索引上的項目。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-188">The element at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="5c8dc-189"><paramref name="index" /> 小於零，或是大於或等於 <see cref="P:System.Span`1.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-189"><paramref name="index" /> is less than zero or greater than or equal to <see cref="P:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Span`1&lt;!T&gt; Item(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Span&lt;T&gt; default[Range] { Span&lt;T&gt; get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Item(Range) : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5c8dc-190">傳回目前範圍的長度。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-190">Returns the length of the current span.</span></span></summary>
        <value><span data-ttu-id="5c8dc-191">目前範圍的長度。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-191">The length of the current span.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="5c8dc-192">要比較的第一個範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-192">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="5c8dc-193">要比較的第二個範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-193">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="5c8dc-194">傳回值，指出兩個 <see cref="T:System.Span`1" /> 物件是否相等。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-194">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-195">如果兩個 <see cref="T:System.Span`1" /> 物件相等則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-195"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-196">兩個<xref:System.Span%601>物件是否相等，如果它們有相同的長度和對應的項目`left`和`right`指向相同的記憶體。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-196">Two <xref:System.Span%601> objects are equal if they have the same length and the corresponding elements of `left` and `right` point to the same memory.</span></span> <span data-ttu-id="5c8dc-197">請注意，測試是否相等的用途*不*嘗試判斷內容是否相等。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-197">Note that the test for equality does *not* attempt to determine whether the contents are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="segment"><span data-ttu-id="5c8dc-198">要轉換成 <see cref="T:System.Span`1" /> 的陣列區段。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-198">The array segment to be converted to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="5c8dc-199">定義從 <see cref="T:System.ArraySegment`1" /> 到 <see cref="T:System.Span`1" /> 的隱含轉換。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-199">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-200">對應至陣列區段的範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-200">A span that corresponds to the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="5c8dc-201">物件，要轉換成 <see cref="T:System.ReadOnlySpan`1" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-201">The object to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="5c8dc-202">定義從 <see cref="T:System.Span`1" /> 到 <see cref="T:System.ReadOnlySpan`1" /> 的隱含轉換。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-202">Defines an implicit conversion of a <see cref="T:System.Span`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-203">對應至目前執行個體的唯讀範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-203">A read-only span that corresponds to the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="5c8dc-204">要轉換成 <see cref="T:System.Span`1" /> 的陣列。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-204">The array to convert to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="5c8dc-205">定義從陣列到 <see cref="T:System.Span`1" /> 的隱含轉換。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-205">Defines an implicit conversion of an array to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-206">對應至 <paramref name="array" /> 的範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-206">The span that corresponds to <paramref name="array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="5c8dc-207">要比較的第一個範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-207">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="5c8dc-208">要比較的第二個範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-208">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="5c8dc-209">傳回值，指出兩個 <see cref="T:System.Span`1" /> 物件是否不相等。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-209">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-210">如果兩個 <see cref="T:System.Span`1" /> 物件不相等則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-210"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-211">兩個<xref:System.Span%601>物件是否相等如果它們有不同的長度或對應的項目`left`和`right`不可都指向相同的記憶體。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-211">Two <xref:System.Span%601> objects are equal if they have different lengths or if the corresponding elements of `left` and `right` do not point to the same memory.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Slice : Index -&gt; Span&lt;'T&gt;" Usage="span.Slice startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="5c8dc-212">要開始配量的索引。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-212">The index at which to begin the slice.</span></span></param>
        <summary><span data-ttu-id="5c8dc-213">從起始於指定索引的目前範圍形成配量。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-213">Forms a slice out of the current span that begins at a specified index.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-214">由從 <paramref name="index" /> 到範圍結尾的目前範圍之所有項目組成的範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-214">A span that consists of all elements of the current span from <paramref name="index" /> to the end of the span.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5c8dc-215"><paramref name="index" /> 小於零，或是大於或等於 <see cref="T:System.Span`1.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-215"><paramref name="index" /> is less than zero or greater than or equal to <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Range range);" />
      <MemberSignature Language="F#" Value="member this.Slice : Range -&gt; Span&lt;'T&gt;" Usage="span.Slice range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="5c8dc-216">要開始此配量的索引。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-216">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="5c8dc-217">配量所需的長度。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-217">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="5c8dc-218">從起始於指定索引之指定長度的目前範圍形成配量。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-218">Forms a slice out of the current span starting at a specified index for a specified length.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-219">由起始於 <paramref name="index" /> 目前範圍之 <paramref name="length" /> 項目組成的範圍。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-219">A span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="index" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5c8dc-220"><paramref name="start" /> 或 <paramref name="start" /> + <paramref name="index" /> 小於零或大於 <see cref="T:System.Span`1.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-220"><paramref name="start" /> or <paramref name="start" /> + <paramref name="index" /> is less than zero or greater than <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5c8dc-221">將這個範圍的內容複製到新的陣列。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-221">Copies the contents of this span into a new array.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-222">陣列，其中包含目前範圍中的資料。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-222">An array containing the data in the current span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-223">這個方法會執行堆積配置，因此應該儘可能避免。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-223">This method performs a heap allocation and therefore should be avoided if possible.</span></span> <span data-ttu-id="5c8dc-224">它所支援的 Api 時，有時必須<xref:System.Span%601>物件時無法使用，但搭配使用陣列的 api。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-224">It it sometimes necessary when APIs that support <xref:System.Span%601> objects are not available but APIs that work with arrays are.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5c8dc-225">傳回此 <see cref="T:System.Span`1" /> 物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-225">Returns the string representation of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-226">此 <see cref="T:System.Span`1" /> 物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-226">The string representation of this <see cref="T:System.Span`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="5c8dc-227">針對`Span<Char>`，則`ToString`方法會傳回<xref:System.String>包含指向字元<xref:System.Span%601>。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-227">For a `Span<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the <xref:System.Span%601>.</span></span> <span data-ttu-id="5c8dc-228">否則，它會傳回<xref:System.String>的類型和數目的項目名稱，<xref:System.Span%601>包含。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-228">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the <xref:System.Span%601> contains.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="5c8dc-229">複製作業的目標。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-229">The target of the copy operation.</span></span></param>
        <summary><span data-ttu-id="5c8dc-230">嘗試將目前的 <see cref="T:System.Span`1" /> 複製到目的地 <see cref="T:System.Span`1" />，並傳回值，指出複製作業是否成功。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-230">Attempts to copy the current <see cref="T:System.Span`1" /> to a destination <see cref="T:System.Span`1" /> and returns a value that indicates whether the copy operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="5c8dc-231">若複製作業成功，即為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-231"><see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="5c8dc-232">這個方法會複製所有`source`要`destination`即使`source`和`destination`重疊。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-232">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

<span data-ttu-id="5c8dc-233">如果`destination`短於來源<xref:System.Span%601>，這個方法會傳回`false`，並不會寫入資料到`destination`。</span><span class="sxs-lookup"><span data-stu-id="5c8dc-233">If `destination` is shorter than the source <xref:System.Span%601>, this method returns `false`, and no data is written to `destination`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>