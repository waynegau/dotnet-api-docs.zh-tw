<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6eccab7743830eb390cf2966272244bf716e11b3" /><Meta Name="ms.sourcegitcommit" Value="75eca440f8f4d595506405f48961f38649e160d7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="06/01/2019" /><Meta Name="ms.locfileid" Value="66457965" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="61d7d-101">表示物件，這個物件會處理將工作排入至執行緒上的低階工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-102">執行個體<xref:System.Threading.Tasks.TaskScheduler>類別代表工作排程器。</span><span class="sxs-lookup"><span data-stu-id="61d7d-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="61d7d-103">工作排程器可確保最終會執行工作 (Task) 的工作 (Work)。</span><span class="sxs-lookup"><span data-stu-id="61d7d-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="61d7d-104">預設工作排程器是以 .NET Framework 4 執行緒集區為基礎，其可提供工作竊取 (以達到平衡負載)、執行緒插入/停用 (以達到最大輸送量)，以及整體良好效能。</span><span class="sxs-lookup"><span data-stu-id="61d7d-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="61d7d-105">這應該足以應付大多數的情況。</span><span class="sxs-lookup"><span data-stu-id="61d7d-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="61d7d-106"><xref:System.Threading.Tasks.TaskScheduler>類別也可做為所有可自訂的排程邏輯的擴充點。</span><span class="sxs-lookup"><span data-stu-id="61d7d-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="61d7d-107">這包括機制，例如如何排程執行的工作，以及如何排定的工作應該公開給偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="61d7d-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="61d7d-108">如果您需要特殊的功能，您可以建立自訂排程器，並啟用針對特定工作或查詢。</span><span class="sxs-lookup"><span data-stu-id="61d7d-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="61d7d-109">本主題內容：</span><span class="sxs-lookup"><span data-stu-id="61d7d-109">In this topic:</span></span>  
[<span data-ttu-id="61d7d-110">預設工作排程器和執行緒集區</span><span class="sxs-lookup"><span data-stu-id="61d7d-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="61d7d-111">全域佇列與本機佇列</span><span class="sxs-lookup"><span data-stu-id="61d7d-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="61d7d-112">工作竊取</span><span class="sxs-lookup"><span data-stu-id="61d7d-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="61d7d-113">長時間執行的工作</span><span class="sxs-lookup"><span data-stu-id="61d7d-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="61d7d-114">內嵌工作</span><span class="sxs-lookup"><span data-stu-id="61d7d-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="61d7d-115">指定同步處理內容</span><span class="sxs-lookup"><span data-stu-id="61d7d-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="61d7d-116">預設工作排程器和執行緒集區</span><span class="sxs-lookup"><span data-stu-id="61d7d-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="61d7d-117">工作平行程式庫和 PLINQ 的預設排程器會使用.NET Framework 執行緒集區，由<xref:System.Threading.ThreadPool>類別，以排入佇列，並執行工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="61d7d-118">執行緒集區會使用所提供的資訊<xref:System.Threading.Tasks.Task>有效率地支援細部平行處理原則 （存留較短的工作單位） 的平行工作和查詢通常代表的型別。</span><span class="sxs-lookup"><span data-stu-id="61d7d-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="61d7d-119">全域佇列與本機佇列</span><span class="sxs-lookup"><span data-stu-id="61d7d-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="61d7d-120">執行緒集區會維護全域 FIFO （先進先出） 工作在每個應用程式定義域中為執行緒的佇列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="61d7d-121">每當程式呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType>(或<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 方法，工作放入這個共用佇列，最後再從佇列到下一個可用的執行緒。</span><span class="sxs-lookup"><span data-stu-id="61d7d-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="61d7d-122">從.NET Framework 4 開始，此佇列已改良為使用類似的無鎖定演算法<xref:System.Collections.Concurrent.ConcurrentQueue%601>類別。</span><span class="sxs-lookup"><span data-stu-id="61d7d-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="61d7d-123">藉由使用這種無鎖定實作，執行緒集區會花較少的時間，放入或移出佇列的工作項目。</span><span class="sxs-lookup"><span data-stu-id="61d7d-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="61d7d-124">此效能優點是能夠使用執行緒集區的所有程式。</span><span class="sxs-lookup"><span data-stu-id="61d7d-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="61d7d-125">如同任何其他的工作 (Work) 項目，最上層工作 (Task) (也就是不是在其他工作 (Task) 的內容中建立的工作 (Task)) 會放入全域佇列中。</span><span class="sxs-lookup"><span data-stu-id="61d7d-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="61d7d-126">不過，巢狀工作或子工作 (也就是在其他工作的內容中建立的工作) 的處理方式則相當不同。</span><span class="sxs-lookup"><span data-stu-id="61d7d-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="61d7d-127">子工作或巢狀工作會放入執行父工作的執行緒專屬的本機佇列中。</span><span class="sxs-lookup"><span data-stu-id="61d7d-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="61d7d-128">父工作可以是最上層工作，也可以是其他工作的子工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="61d7d-129">這個執行緒在準備好要處理更多工作時，會先查看本機佇列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="61d7d-130">如果本機佇列中有待處理的工作項目，則可以快速存取這些工作項目。</span><span class="sxs-lookup"><span data-stu-id="61d7d-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="61d7d-131">本機佇列存取後進先出順序 (LIFO) 來保留快取位置，並減少爭用情形。</span><span class="sxs-lookup"><span data-stu-id="61d7d-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="61d7d-132">如需子工作和巢狀的工作的詳細資訊，請參閱[附加與中斷連結子工作](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="61d7d-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="61d7d-133">使用本機佇列不僅可減少全域佇列中，不足的壓力，也會利用資料位置。</span><span class="sxs-lookup"><span data-stu-id="61d7d-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="61d7d-134">在本機的工作項目排入佇列經常在記憶體中實際上是彼此接近的參考資料結構。</span><span class="sxs-lookup"><span data-stu-id="61d7d-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="61d7d-135">在這些情況下，資料已經在快取之後的第一個工作已經執行，而且可以快速存取。</span><span class="sxs-lookup"><span data-stu-id="61d7d-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="61d7d-136">兩者[平行 LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md)而<xref:System.Threading.Tasks.Parallel>廣泛，類別使用巢狀工作和子工作，並使用本機工作佇列達到顯著的加速效果。</span><span class="sxs-lookup"><span data-stu-id="61d7d-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="61d7d-137">工作竊取</span><span class="sxs-lookup"><span data-stu-id="61d7d-137">Work stealing</span></span>  
 <span data-ttu-id="61d7d-138">從.NET Framework 4 開始，執行緒集區也提供工作竊取演算法，可協助您確認沒有任何執行緒會有某些閒置而其他人仍有工作在其佇列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="61d7d-139">執行緒集區的執行緒在準備好要處理更多工作時，會先查看自己本機佇列的開頭，接著查看全域佇列，然後再查看其他執行緒的本機佇列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="61d7d-140">如果在其他執行緒的本機佇列中發現了工作項目，它會先套用啟發學習法，確定可有效率地執行工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="61d7d-141">如果可以它會移出佇列工作中的項目 （以 FIFO 順序） 的結尾。</span><span class="sxs-lookup"><span data-stu-id="61d7d-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="61d7d-142">這樣可以減少本機佇列爭用的情形發生，並保留資料位置。</span><span class="sxs-lookup"><span data-stu-id="61d7d-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="61d7d-143">這個架構會讓執行緒集區進行負載平衡工作比舊版更有效率。</span><span class="sxs-lookup"><span data-stu-id="61d7d-143">This architecture helps the thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="61d7d-144">長時間執行的工作</span><span class="sxs-lookup"><span data-stu-id="61d7d-144">Long-running tasks</span></span>  
 <span data-ttu-id="61d7d-145">您可以明確防止將工作放入本機佇列中。</span><span class="sxs-lookup"><span data-stu-id="61d7d-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="61d7d-146">例如，您可能知道某個工作項目會執行相當長的一段時間，而可能阻礙本機佇列上所有其他工作項目的進度。</span><span class="sxs-lookup"><span data-stu-id="61d7d-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="61d7d-147">在這種情況下，您可以指定 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 選項，提示排程器可能需要再加入一個執行緒來執行工作，才不會阻礙本機佇列上其他執行緒或工作項目的進度。</span><span class="sxs-lookup"><span data-stu-id="61d7d-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="61d7d-148">使用此選項您避免在執行緒集區完全，包括全域和本機佇列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="61d7d-149">內嵌工作</span><span class="sxs-lookup"><span data-stu-id="61d7d-149">Task inlining</span></span>  
 <span data-ttu-id="61d7d-150">在某些情況下，當等候 <xref:System.Threading.Tasks.Task> 時，您可以在執行等候作業的執行緒上以同步方式執行它。</span><span class="sxs-lookup"><span data-stu-id="61d7d-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="61d7d-151">這樣可以提升效能，因為可以改為使用現有的執行緒，而不需要使用會被封鎖的額外執行緒。</span><span class="sxs-lookup"><span data-stu-id="61d7d-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="61d7d-152">為防止因重新進入而導致的錯誤，只有當在相關執行緒的本機佇列中發現等候目標時，才會發生工作內嵌。</span><span class="sxs-lookup"><span data-stu-id="61d7d-152">To prevent errors due to reentrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="61d7d-153">指定同步處理內容</span><span class="sxs-lookup"><span data-stu-id="61d7d-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="61d7d-154">您可以使用 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 方法，指定應該將工作排定在特定執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="61d7d-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="61d7d-155">在 Windows Form 和 Windows Presentation Foundation 等架構中，只有在當初建立使用者介面物件的執行緒上執行的程式碼能夠存取該 UI 物件，因此很適合使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="61d7d-156">下列範例會使用<xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>排程的工作建立使用者介面 (UI) 控制項的相同執行緒上的 Windows Presentation Foundation (WPF) 應用程式中的方法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="61d7d-157">此範例會建立 mosaic 從指定的目錄中隨機選取的映像。</span><span class="sxs-lookup"><span data-stu-id="61d7d-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="61d7d-158">WPF 物件會用來載入和調整影像大小。</span><span class="sxs-lookup"><span data-stu-id="61d7d-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="61d7d-159">未經處理的像素接著會傳遞至工作會使用<xref:System.Threading.Tasks.Parallel.For%2A>迴圈，以像素資料寫入大型的單一位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="61d7d-160">任何同步處理不是必要的因為沒有任何兩個磚佔據相同的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="61d7d-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="61d7d-161">圖格也依照任何順序寫入，因為它們的位置計算獨立於任何其他的圖格。</span><span class="sxs-lookup"><span data-stu-id="61d7d-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="61d7d-162">大型的陣列然後傳遞給像素資料載入影像控制項的位置在 UI 執行緒執行的工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="61d7d-163">此範例會將在 UI 執行緒外的資料移動、 修改使用平行迴圈和<xref:System.Threading.Tasks.Task>物件，然後再將它傳遞回 UI 執行緒執行的工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="61d7d-164">當您必須使用工作平行程式庫來執行作業，不支援由 WPF API，或不夠快，則這個方法會很有用。</span><span class="sxs-lookup"><span data-stu-id="61d7d-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="61d7d-165">在 WPF 中建立的映像 mosaic 的另一種方式是使用<xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType>控制項，並將影像加入至它。</span><span class="sxs-lookup"><span data-stu-id="61d7d-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="61d7d-166"><xref:System.Windows.Controls.WrapPanel>處理定位的圖格的工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="61d7d-167">不過，這項工作只可以在 UI 執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="61d7d-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="61d7d-168">若要建立範例，在 Visual Studio 中建立 WPF 應用程式專案並將它命名為 WPF_CS1 (如C#的 WPF 專案) 或 WPF_VB1 （適用於 Visual Basic WPF 專案）。</span><span class="sxs-lookup"><span data-stu-id="61d7d-168">To create the example, create a WPF application project in Visual Studio and name it WPF_CS1 (for a C# WPF project) or WPF_VB1 (for a Visual Basic WPF project).</span></span> <span data-ttu-id="61d7d-169">然後執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="61d7d-169">Then do the following:</span></span>  
  
1. <span data-ttu-id="61d7d-170">在 [設計] 檢視中，拖曳<xref:System.Windows.Controls.Image>控制項從**工具箱**拖曳至設計介面的左上角。</span><span class="sxs-lookup"><span data-stu-id="61d7d-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** onto the upper left corner of the design surface.</span></span> <span data-ttu-id="61d7d-171">在 **名稱**的文字方塊**屬性**視窗中，命名控制 「 映像 」。</span><span class="sxs-lookup"><span data-stu-id="61d7d-171">In the **Name** textbox of the **Properties** window, name the control "image".</span></span>    
  
2. <span data-ttu-id="61d7d-172">拖曳<xref:System.Windows.Controls.Button>控制項從**工具箱**到應用程式視窗左側的下半部。</span><span class="sxs-lookup"><span data-stu-id="61d7d-172">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="61d7d-173">在 [XAML] 檢視中，指定<xref:System.Windows.Controls.ContentControl.Content%2A>屬性為"Make mosaic"按鈕，並指定其<xref:System.Windows.FrameworkElement.Width>屬性設為"100"。</span><span class="sxs-lookup"><span data-stu-id="61d7d-173">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a mosaic", and specify its <xref:System.Windows.FrameworkElement.Width> property as "100".</span></span> <span data-ttu-id="61d7d-174">連接<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件`button_Click`加上的範例程式碼中定義的事件處理常式`Click="button_Click"`到`<Button>`項目。</span><span class="sxs-lookup"><span data-stu-id="61d7d-174">Connect the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with the `button_Click` event handler defined in the example's code by adding `Click="button_Click"` to the `<Button>` element.</span></span> <span data-ttu-id="61d7d-175">在 **名稱**的文字方塊**屬性**視窗中，命名控制 「 按鈕 」。</span><span class="sxs-lookup"><span data-stu-id="61d7d-175">In the **Name** textbox of the **Properties** window, name the control "button".</span></span>  
  
3. <span data-ttu-id="61d7d-176">MainWindow.xaml.cs 或 MainWindow.xaml.vb 檔案的整個內容取代這個範例的程式碼。</span><span class="sxs-lookup"><span data-stu-id="61d7d-176">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="61d7d-177">針對C#WPF 專案中，請確定工作區的名稱符合專案名稱。</span><span class="sxs-lookup"><span data-stu-id="61d7d-177">For a C# WPF project, make sure that the name of the workspace matches the project name.</span></span> 
  
4. <span data-ttu-id="61d7d-178">此範例會讀取名為雰枆 C:\Users\Public\Pictures\Sample Pictures 目錄中的 JPEG 影像\\。</span><span class="sxs-lookup"><span data-stu-id="61d7d-178">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="61d7d-179">建立目錄和放置一些映像，或變更以指向其他包含映像的目錄路徑。</span><span class="sxs-lookup"><span data-stu-id="61d7d-179">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span> 
  
<span data-ttu-id="61d7d-180">此範例中會有一些限制。</span><span class="sxs-lookup"><span data-stu-id="61d7d-180">This example has some limitations.</span></span> <span data-ttu-id="61d7d-181">例如，支援只有 32-位元-每個像素映像;其他格式的映像已損毀的<xref:System.Windows.Media.Imaging.BitmapImage>調整大小作業期間的物件。</span><span class="sxs-lookup"><span data-stu-id="61d7d-181">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="61d7d-182">此外，原始碼映像全都必須大於的並排顯示大小。</span><span class="sxs-lookup"><span data-stu-id="61d7d-182">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="61d7d-183">為進一步的練習中，您可以新增功能，以處理多個像素格式和檔案大小。</span><span class="sxs-lookup"><span data-stu-id="61d7d-183">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
## Examples  
 <span data-ttu-id="61d7d-184">下列範例取自[使用.NET Framework 4 進行平行程式設計的範例](https://go.microsoft.com/fwlink/?LinkID=165717)MSDN Code Gallery 網站上。</span><span class="sxs-lookup"><span data-stu-id="61d7d-184">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="61d7d-185">它會建立自訂工作排程器，以限制應用程式所使用的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="61d7d-185">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="61d7d-186">然後啟動兩組工作，並顯示工作和工作執行所在之執行緒的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="61d7d-186">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="61d7d-187">此外，數個範例工作排程器可在程式碼庫上：[使用.NET Framework 4 進行平行程式設計的範例](https://go.microsoft.com/fwlink/?LinkID=165717)。</span><span class="sxs-lookup"><span data-stu-id="61d7d-187">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="61d7d-188">所有抽象成員<see cref="T:System.Threading.Tasks.TaskScheduler" />型別是安全執行緒，且可能會同時使用從多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="61d7d-188">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-189">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-189">Task Parallel Library (TPL)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61d7d-190">初始化 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-190">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-191">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-191">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61d7d-192">取得與目前執行之工作相關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="61d7d-193">傳回與目前執行之工作相關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-194">不會從呼叫內工作，當<xref:System.Threading.Tasks.TaskScheduler.Current%2A>會傳回<xref:System.Threading.Tasks.TaskScheduler.Default%2A>排程器。</span><span class="sxs-lookup"><span data-stu-id="61d7d-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="61d7d-195">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-196">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-196">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61d7d-197">取得 .NET Framework 提供的預設 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="61d7d-197">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span></span></summary>
        <value><span data-ttu-id="61d7d-198">傳回預設 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="61d7d-198">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-199">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-199">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-200">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-200">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61d7d-201">釋出所有與這個排程器相關聯的資源。</span><span class="sxs-lookup"><span data-stu-id="61d7d-201">Frees all resources associated with this scheduler.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61d7d-202">建立與目前 <see cref="T:System.Threading.SynchronizationContext" />關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-202">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="61d7d-203">與目前的 <see cref="T:System.Threading.SynchronizationContext" /> 關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />，由 <see cref="P:System.Threading.SynchronizationContext.Current" /> 決定。</span><span class="sxs-lookup"><span data-stu-id="61d7d-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-204">所有<xref:System.Threading.Tasks.Task>佇列所傳回的執行個體將會執行排程器，透過呼叫<xref:System.Threading.SynchronizationContext.Post%2A>在內容上的方法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-204">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="61d7d-205">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-205">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="61d7d-206">目前的 SynchronizationContext 不可當做 TaskScheduler 使用。</span><span class="sxs-lookup"><span data-stu-id="61d7d-206">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-207">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-207">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61d7d-208">僅限偵錯工具支援，針對目前已排入至排程器中等候執行的 <see cref="T:System.Threading.Tasks.Task" /> 執行個體，產生可列舉項目。</span><span class="sxs-lookup"><span data-stu-id="61d7d-208">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="61d7d-209">可列舉項目，允許偵錯工具在目前已排入至這個排程器中的工作之間周遊。</span><span class="sxs-lookup"><span data-stu-id="61d7d-209">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-210">類別衍生自<xref:System.Threading.Tasks.TaskScheduler>會實作這個方法，以支援偵錯工具整合。</span><span class="sxs-lookup"><span data-stu-id="61d7d-210">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="61d7d-211">這個方法會只叫用.NET Framework 偵錯工具要求資料的存取權時。</span><span class="sxs-lookup"><span data-stu-id="61d7d-211">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="61d7d-212">將偵錯公用程式來存取工作可周遊的可列舉值傳回目前已排入至這個排程器，讓偵錯工具提供這項資訊的使用者介面中的表示法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-212">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="61d7d-213">請務必請注意，呼叫這個方法時，此程序中的所有其他執行緒就會被凍結。</span><span class="sxs-lookup"><span data-stu-id="61d7d-213">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="61d7d-214">因此，務必避免與其他可能會導致封鎖的執行緒同步處理。</span><span class="sxs-lookup"><span data-stu-id="61d7d-214">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="61d7d-215">如果同步處理是必要的而且您無法取得這個方法中的鎖定，然後您應該擲回例外狀況，讓偵錯工具不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="61d7d-215">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not block.</span></span> <span data-ttu-id="61d7d-216">下列範例會示範一個可能的方法，在 C# 中：</span><span class="sxs-lookup"><span data-stu-id="61d7d-216">The following example shows one possible approach in C#:</span></span>
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="61d7d-217">此外，這個方法，並傳回列舉不能修改任何全域可見狀態。</span><span class="sxs-lookup"><span data-stu-id="61d7d-217">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="61d7d-218">傳回可列舉應該絕不會是 null。</span><span class="sxs-lookup"><span data-stu-id="61d7d-218">The returned enumerable should never be null.</span></span> <span data-ttu-id="61d7d-219">如果目前沒有任何已排入佇列的工作，應該改為傳回空的可列舉。</span><span class="sxs-lookup"><span data-stu-id="61d7d-219">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="61d7d-220">開發人員要實作自訂的偵錯工具不應該直接呼叫這個方法，但是應該使用的內部包裝函式方法`GetScheduledTasksForDebugger`改為： `internal Task[] GetScheduledTasksForDebugger()`。</span><span class="sxs-lookup"><span data-stu-id="61d7d-220">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="61d7d-221">這個包裝函式方法會傳回工作，而不是可列舉陣列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-221">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="61d7d-222">若要擷取一份作用中排程器，請使用內部的方法`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`。</span><span class="sxs-lookup"><span data-stu-id="61d7d-222">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="61d7d-223">這個靜態方法傳回的所有作用中的陣列<xref:System.Threading.Tasks.TaskScheduler>執行個體。</span><span class="sxs-lookup"><span data-stu-id="61d7d-223">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="61d7d-224">您可以接著使用`GetScheduledTasksForDebugger`來擷取它的已排程的工作清單的每個排程器執行個體上。</span><span class="sxs-lookup"><span data-stu-id="61d7d-224">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="61d7d-225">這個排程器無法在這個階段產生佇列的工作清單。</span><span class="sxs-lookup"><span data-stu-id="61d7d-225">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-226">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-226">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61d7d-227">取得這個 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="61d7d-227">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="61d7d-228">傳回這個 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="61d7d-228">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-229">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-229">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-230">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-230">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61d7d-231">表示這個 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 可以支援的最大並行層級。</span><span class="sxs-lookup"><span data-stu-id="61d7d-231">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="61d7d-232">傳回整數，表示最大並行層級。</span><span class="sxs-lookup"><span data-stu-id="61d7d-232">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="61d7d-233">預設排程器會傳回 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-233">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-234">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-234">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-235">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-235">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="61d7d-236">要排入的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-236">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="61d7d-237">將 <see cref="T:System.Threading.Tasks.Task" /> 排入至排程器。</span><span class="sxs-lookup"><span data-stu-id="61d7d-237">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-238">類別衍生自<xref:System.Threading.Tasks.TaskScheduler>實作這個方法，以接受 工作排程器上進行排程。</span><span class="sxs-lookup"><span data-stu-id="61d7d-238">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="61d7d-239">一般實作會將工作儲存在內部資料結構中，會由會在未來的某個時間點執行這些工作的執行緒。</span><span class="sxs-lookup"><span data-stu-id="61d7d-239">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="61d7d-240">這個方法只是由.NET Framework 呼叫，並不應該直接由衍生類別呼叫。</span><span class="sxs-lookup"><span data-stu-id="61d7d-240">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="61d7d-241">這是必要的維護系統的一致性。</span><span class="sxs-lookup"><span data-stu-id="61d7d-241">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="61d7d-242"><paramref name="task" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="61d7d-242">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-243">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-243">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="61d7d-244">要清除的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-244">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="61d7d-245">嘗試清除之前排入至這個排程器的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-245">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="61d7d-246">布林值，表示是否已經成功清除 <paramref name="task" /> 引數。</span><span class="sxs-lookup"><span data-stu-id="61d7d-246">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-247">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-247">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 <span data-ttu-id="61d7d-248">這個方法可能會執行 finally 區塊;因此它應該傳回儘速因此讓任何資源，例如<xref:System.Threading.CancellationTokenRegistration>可以及時的處置物件。</span><span class="sxs-lookup"><span data-stu-id="61d7d-248">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="61d7d-249"><paramref name="task" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="61d7d-249">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-250">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-250">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="61d7d-251">要執行的 <see cref="T:System.Threading.Tasks.Task" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="61d7d-251">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="61d7d-252">嘗試在這個排程器上執行提供的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-252">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="61d7d-253">布林值，如果已成功執行 <paramref name="task" /> 則為 true，否則為 false。</span><span class="sxs-lookup"><span data-stu-id="61d7d-253">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="61d7d-254">執行失敗的常見原因是之前已執行過該工作，或另一個執行緒正在執行該工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-254">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-255">排程器實作所隨附<xref:System.Threading.Tasks.Task>執行個體，以透過執行<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法或<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-255">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="61d7d-256">當排程器認為適合用來執行所提供的工作，<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>應該用來執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-256">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="61d7d-257">TryExecuteTask 處理執行的工作，包括動作引動過程、 例外狀況處理、 狀態管理和生命週期控制的所有層面。</span><span class="sxs-lookup"><span data-stu-id="61d7d-257">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="61d7d-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 必須只用於由.NET Framework 基礎結構提供給這個排程器的工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="61d7d-259">它不應該用來執行任意工作，透過自訂機制取得。</span><span class="sxs-lookup"><span data-stu-id="61d7d-259">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="61d7d-260"><paramref name="task" /> 與此排程器無關。</span><span class="sxs-lookup"><span data-stu-id="61d7d-260">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-261">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-261">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="61d7d-262">要執行的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="61d7d-262">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="61d7d-263">布林值，表示之前是否已排入過工作。</span><span class="sxs-lookup"><span data-stu-id="61d7d-263">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="61d7d-264">如果這個參數為 True，則可能之前已排入 (排定) 過工作，如果為 False，則表示未排入過工作，系統便會隨即執行此呼叫，以內嵌方式執行工作，而不將它排入佇列。</span><span class="sxs-lookup"><span data-stu-id="61d7d-264">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="61d7d-265">判斷是否可以在這個呼叫中同步執行所提供的 <see cref="T:System.Threading.Tasks.Task" />，如果可以，即加以執行。</span><span class="sxs-lookup"><span data-stu-id="61d7d-265">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="61d7d-266">布林值，表示工作是否以內嵌方式執行。</span><span class="sxs-lookup"><span data-stu-id="61d7d-266">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-267">類別衍生自<xref:System.Threading.Tasks.TaskScheduler>實作此函式來初始化工作物件上的等候的執行緒上支援內嵌在工作執行。</span><span class="sxs-lookup"><span data-stu-id="61d7d-267">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="61d7d-268">內嵌執行是選擇性的並要求可能會遭到拒絕，藉由傳回 false。</span><span class="sxs-lookup"><span data-stu-id="61d7d-268">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="61d7d-269">不過，更多的工作，可以內嵌、 較佳的排程器將會調整。</span><span class="sxs-lookup"><span data-stu-id="61d7d-269">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="61d7d-270">事實上，排程器的內嵌太少可能容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="61d7d-270">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="61d7d-271">適當的實作應該確定在排程器所保證的原則下執行的要求可以成功地內嵌。</span><span class="sxs-lookup"><span data-stu-id="61d7d-271">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="61d7d-272">例如，如果排程器會使用專用的執行緒來執行工作，來自該執行緒的任何內嵌要求應該會成功。</span><span class="sxs-lookup"><span data-stu-id="61d7d-272">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="61d7d-273">如果排程器會決定執行內嵌執行，它應該這樣呼叫基底的 TaskScheduler<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>與提供的工作物件，將傳播的傳回值的方法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-273">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="61d7d-274">它也可能是適用於從其內部資料結構移除內嵌的工作，如果它會決定要接受此內嵌要求排程器。</span><span class="sxs-lookup"><span data-stu-id="61d7d-274">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="61d7d-275">請注意，在某些情況下排程器可能會要求內嵌工作先前未提供給它與<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="61d7d-275">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="61d7d-276">在衍生的排程器會負責確保呼叫執行緒很適合執行指定的工作而言它自己的排程，並執行原則而言。</span><span class="sxs-lookup"><span data-stu-id="61d7d-276">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="61d7d-277">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="61d7d-277">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="61d7d-278"><paramref name="task" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="61d7d-278">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="61d7d-279"><paramref name="task" /> 已經執行。</span><span class="sxs-lookup"><span data-stu-id="61d7d-279">The <paramref name="task" /> was already executed.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-280">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-280">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61d7d-281">當錯誤工作未觀察到的例外狀況將觸發例外狀況擴大原則時發生，根據預設，這會終止處理程序。</span><span class="sxs-lookup"><span data-stu-id="61d7d-281">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61d7d-282">此應用程式的全網域的事件會提供一個機制，以避免例外狀況擴大原則 （其預設的情況下，終止處理序），從觸發。</span><span class="sxs-lookup"><span data-stu-id="61d7d-282">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="61d7d-283">為了方便開發人員撰寫工作為基礎的非同步程式碼[!INCLUDE[net_v45](~/includes/net-v45-md.md)]變成未觀察到的例外狀況的預設例外狀況行為。</span><span class="sxs-lookup"><span data-stu-id="61d7d-283">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="61d7d-284">雖然仍未觀察到的例外狀況引發<xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>例外狀況，處理程序不會終止預設。</span><span class="sxs-lookup"><span data-stu-id="61d7d-284">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="61d7d-285">相反地，例外狀況是由處理執行階段引發事件，不論事件處理常式是否會觀察到例外狀況之後。</span><span class="sxs-lookup"><span data-stu-id="61d7d-285">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="61d7d-286">可以設定此行為。</span><span class="sxs-lookup"><span data-stu-id="61d7d-286">This behavior can be configured.</span></span> <span data-ttu-id="61d7d-287">開頭[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，您可以使用[ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md)要還原的行為組態項目[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]並且終止處理序：</span><span class="sxs-lookup"><span data-stu-id="61d7d-287">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the [`<ThrowUnobservedTaskExceptions>`](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="61d7d-288">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="61d7d-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md"><span data-ttu-id="61d7d-289">&lt;ThrowUnobservedTaskExceptions&gt;項目</span><span class="sxs-lookup"><span data-stu-id="61d7d-289">&lt;ThrowUnobservedTaskExceptions&gt; Element</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>