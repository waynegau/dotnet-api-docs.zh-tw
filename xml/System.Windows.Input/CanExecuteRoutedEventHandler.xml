<Type Name="CanExecuteRoutedEventHandler" FullName="System.Windows.Input.CanExecuteRoutedEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40314ee81839ebd0b1ef25f5f831b2e68f2b0ad5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CanExecuteRoutedEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CanExecuteRoutedEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub CanExecuteRoutedEventHandler(sender As Object, e As CanExecuteRoutedEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void CanExecuteRoutedEventHandler(System::Object ^ sender, CanExecuteRoutedEventArgs ^ e);" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.Input.CanExecuteRoutedEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">
      <span data-ttu-id="6b58f-101">正在叫用處理常式的命令目標。</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b58f-101">The command target that is invoking the handler.</span>
      </span>
    </param>
    <param name="e">
      <span data-ttu-id="6b58f-102">事件資料。</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b58f-102">The event data.</span>
      </span>
    </param>
    <summary>
      <span data-ttu-id="6b58f-103">代表將處理 <see cref="E:System.Windows.Input.CommandBinding.CanExecute" /> 事件的方法。</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b58f-103">Represents the method that will handle the <see cref="E:System.Windows.Input.CommandBinding.CanExecute" /> event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b58f-104"><xref:System.Windows.Input.CanExecuteRoutedEventHandler>判斷事件來源相關聯的命令是否可以在命令目標上執行。</span><span class="sxs-lookup"><span data-stu-id="6b58f-104">The <xref:System.Windows.Input.CanExecuteRoutedEventHandler> determines if the command associated with the event source is able to execute on the command target.</span></span> <span data-ttu-id="6b58f-105">命令的命令來源，指定的目標，則可以透過取得目標資訊`sender`。</span><span class="sxs-lookup"><span data-stu-id="6b58f-105">If the command has a command source that specifies a target, then the target information can be obtained through `sender`.</span></span> <span data-ttu-id="6b58f-106">如果<xref:System.Windows.Input.ICommandSource.CommandTarget%2A>未設定，具有鍵盤焦點的項目是目標，且您也可以透過取得`sender`。</span><span class="sxs-lookup"><span data-stu-id="6b58f-106">If the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is not set, the element with keyboard focus is the target, and can also be obtained through `sender`.</span></span>  <span data-ttu-id="6b58f-107">如果它由決定命令可以在目標上執行則<xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType>屬性應該設定為`true`; 否則，請將它設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="6b58f-107">If it is determined that the command can execute on the target, then the <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> property should be set to `true`; otherwise, set it to `false`.</span></span>  
  
 <span data-ttu-id="6b58f-108">您不需要依賴事件資料，以判斷命令、 來源和目標。</span><span class="sxs-lookup"><span data-stu-id="6b58f-108">You do not need to rely on event data to determine the command, source, and target.</span></span> <span data-ttu-id="6b58f-109">雖然這是更難完成如果命令結構依賴廣泛的命令路由，後續事件中的潛在目標上執行相同的命令，您可以限制為已知的可能命令引動過程，處理常式的使用方式路由。</span><span class="sxs-lookup"><span data-stu-id="6b58f-109">You can limit the usage of the handler to known possible command invocations, although this is more difficult to accomplish if your command structure relies extensively on the command routing to execute the same command on successive potential targets in an event route.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b58f-110">下列範例所示<xref:System.Windows.Input.CanExecuteRoutedEventHandler>設定<xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A>至`true`。</span><span class="sxs-lookup"><span data-stu-id="6b58f-110">The following example shows a <xref:System.Windows.Input.CanExecuteRoutedEventHandler> that sets <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> to `true`.</span></span>  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ExecutedRoutedEventHandler" />
  </Docs>
</Type>