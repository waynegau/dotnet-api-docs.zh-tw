<Type Name="SymWriter" FullName="System.Diagnostics.SymbolStore.SymWriter">
  <TypeSignature Language="C#" Value="public class SymWriter : System.Diagnostics.SymbolStore.SymWriterBase, IDisposable, System.Diagnostics.SymbolStore.ISymbolWriter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SymWriter extends System.Diagnostics.SymbolStore.SymWriterBase implements class System.Diagnostics.SymbolStore.ISymbolWriter, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.SymbolStore.SymWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class SymWriter&#xA;Inherits SymWriterBase&#xA;Implements IDisposable, ISymbolWriter" />
  <TypeSignature Language="C++ CLI" Value="public ref class SymWriter : System::Diagnostics::SymbolStore::SymWriterBase, IDisposable, System::Diagnostics::SymbolStore::ISymbolWriter" />
  <AssemblyInfo>
    <AssemblyName>ISymWrapper</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.SymbolStore.SymWriterBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Diagnostics.SymbolStore.ISymbolWriter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="2895d-101">代表 Managed 程式碼的符號寫入器。</span><span class="sxs-lookup"><span data-stu-id="2895d-101">Represents a symbol writer for managed code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-102"><xref:System.Diagnostics.SymbolStore.SymWriter>類別會提供定義文件，序列點、 語彙範圍和變數的方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-102">The <xref:System.Diagnostics.SymbolStore.SymWriter> class provides methods that define documents, sequence points, lexical scopes, and variables.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymWriter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2895d-103">初始化 <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="2895d-103">Initializes a new instance of the <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2895d-104">提供存取 unmanaged 程式碼的能力。</span><span class="sxs-lookup"><span data-stu-id="2895d-104">for the ability to access unmanaged code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymWriter (bool noUnderlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool noUnderlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (noUnderlyingWriter As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymWriter(bool noUnderlyingWriter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="noUnderlyingWriter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noUnderlyingWriter">
          <span data-ttu-id="2895d-105">如果基礎符號寫入器將透過呼叫 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> 方法來提供，則為 <see langword="true" />；如果應該建立預設基礎符號寫入器，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-105"><see langword="true" /> if an underlying symbol writer will be provided by calling the <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> method; <see langword="false" /> if a default underlying symbol writer should be created instead.</span></span></param>
        <summary><span data-ttu-id="2895d-106">指定是否要建立基礎符號寫入器，初始化 <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="2895d-106">Initializes a new instance of the <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> class, specifying whether to create an underlying symbol writer.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2895d-107">關閉 <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> 並將符號認可到符號存放區。</span><span class="sxs-lookup"><span data-stu-id="2895d-107">Closes the <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> and commits the symbols to the symbol store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-108">呼叫後，<xref:System.Diagnostics.SymbolStore.SymWriter>就會變成無效的進一步更新。</span><span class="sxs-lookup"><span data-stu-id="2895d-108">After this call, the <xref:System.Diagnostics.SymbolStore.SymWriter> becomes invalid for further updates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseMethod">
      <MemberSignature Language="C#" Value="public virtual void CloseMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseMethod ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2895d-109">關閉目前的方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-109">Closes the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-110">在關閉方法之後，您無法定義從方法內的符號。</span><span class="sxs-lookup"><span data-stu-id="2895d-110">After a method is closed, you cannot define a symbol from within the method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseNamespace">
      <MemberSignature Language="C#" Value="public virtual void CloseNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseNamespace ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseNamespace();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2895d-111">關閉最近一次使用的命名空間。</span><span class="sxs-lookup"><span data-stu-id="2895d-111">Closes the most recent namespace.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseScope">
      <MemberSignature Language="C#" Value="public virtual void CloseScope (int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseScope(int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseScope (endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseScope(int endOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endOffset"><span data-ttu-id="2895d-112">正好超過範圍中最後一個指令的 IL 位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-112">The IL offset just past the last instruction in the scope.</span></span></param>
        <summary><span data-ttu-id="2895d-113">關閉目前的語彙範圍。</span><span class="sxs-lookup"><span data-stu-id="2895d-113">Closes the current lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-114">關閉範圍之後，您無法定義從方法內的變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-114">After a scope is closed, you cannot define a variable from within the method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url"><span data-ttu-id="2895d-115">識別文件的 URL。</span><span class="sxs-lookup"><span data-stu-id="2895d-115">The URL that identifies the document.</span></span></param>
        <param name="language"><span data-ttu-id="2895d-116">文件語言。</span><span class="sxs-lookup"><span data-stu-id="2895d-116">The document language.</span></span> <span data-ttu-id="2895d-117">這個參數可以是 <see cref="F:System.Guid.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-117">This parameter can be <see cref="F:System.Guid.Empty" />.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="2895d-118">文件語言的廠商識別。</span><span class="sxs-lookup"><span data-stu-id="2895d-118">The identity of the vendor for the document language.</span></span> <span data-ttu-id="2895d-119">這個參數可以是 <see cref="F:System.Guid.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-119">This parameter can be <see cref="F:System.Guid.Empty" />.</span></span></param>
        <param name="documentType"><span data-ttu-id="2895d-120">文件的類型。</span><span class="sxs-lookup"><span data-stu-id="2895d-120">The type of the document.</span></span> <span data-ttu-id="2895d-121">這個參數可以是 <see cref="F:System.Guid.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-121">This parameter can be <see cref="F:System.Guid.Empty" />.</span></span></param>
        <summary><span data-ttu-id="2895d-122">定義來源文件。</span><span class="sxs-lookup"><span data-stu-id="2895d-122">Defines a source document.</span></span></summary>
        <returns><span data-ttu-id="2895d-123">代表文件的 <see cref="T:System.Diagnostics.SymbolStore.ISymbolDocumentWriter" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="2895d-123">The <see cref="T:System.Diagnostics.SymbolStore.ISymbolDocumentWriter" /> object that represents the document.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public virtual void DefineField (System.Diagnostics.SymbolStore.SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineField(valuetype System.Diagnostics.SymbolStore.SymbolToken parent, string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineField (parent As SymbolToken, name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineField(System::Diagnostics::SymbolStore::SymbolToken parent, System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Diagnostics.SymbolStore.SymbolToken" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent"><span data-ttu-id="2895d-124">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-124">This parameter is not used.</span></span></param>
        <param name="name"><span data-ttu-id="2895d-125">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-125">This parameter is not used.</span></span></param>
        <param name="attributes"><span data-ttu-id="2895d-126">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-126">This parameter is not used.</span></span></param>
        <param name="signature"><span data-ttu-id="2895d-127">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-127">This parameter is not used.</span></span></param>
        <param name="addrKind"><span data-ttu-id="2895d-128">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-128">This parameter is not used.</span></span></param>
        <param name="addr1"><span data-ttu-id="2895d-129">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-129">This parameter is not used.</span></span></param>
        <param name="addr2"><span data-ttu-id="2895d-130">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-130">This parameter is not used.</span></span></param>
        <param name="addr3"><span data-ttu-id="2895d-131">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-131">This parameter is not used.</span></span></param>
        <summary><span data-ttu-id="2895d-132">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-132">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2895d-133">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="2895d-133">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalVariable">
      <MemberSignature Language="C#" Value="public virtual void DefineGlobalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineGlobalVariable(string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineGlobalVariable (name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineGlobalVariable(System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2895d-134">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-134">This parameter is not used.</span></span></param>
        <param name="attributes"><span data-ttu-id="2895d-135">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-135">This parameter is not used.</span></span></param>
        <param name="signature"><span data-ttu-id="2895d-136">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-136">This parameter is not used.</span></span></param>
        <param name="addrKind"><span data-ttu-id="2895d-137">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-137">This parameter is not used.</span></span></param>
        <param name="addr1"><span data-ttu-id="2895d-138">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-138">This parameter is not used.</span></span></param>
        <param name="addr2"><span data-ttu-id="2895d-139">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-139">This parameter is not used.</span></span></param>
        <param name="addr3"><span data-ttu-id="2895d-140">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-140">This parameter is not used.</span></span></param>
        <summary><span data-ttu-id="2895d-141">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-141">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2895d-142">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="2895d-142">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLocalVariable">
      <MemberSignature Language="C#" Value="public virtual void DefineLocalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineLocalVariable(string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3, int32 startOffset, int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineLocalVariable (name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer, startOffset As Integer, endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineLocalVariable(System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2895d-143">區域變數名稱。</span><span class="sxs-lookup"><span data-stu-id="2895d-143">The local variable name.</span></span></param>
        <param name="attributes"><span data-ttu-id="2895d-144">使用 <see cref="T:System.Reflection.FieldAttributes" /> 列舉值所指定的區域變數屬性。</span><span class="sxs-lookup"><span data-stu-id="2895d-144">The local variable attributes specified using the <see cref="T:System.Reflection.FieldAttributes" /> enumerator.</span></span></param>
        <param name="signature"><span data-ttu-id="2895d-145">區域變數簽章。</span><span class="sxs-lookup"><span data-stu-id="2895d-145">The local variable signature.</span></span></param>
        <param name="addrKind"><span data-ttu-id="2895d-146">使用 <see cref="T:System.Diagnostics.SymbolStore.SymAddressKind" /> 的 <c>addr1</c>、<c>addr2</c>和 <c>addr3</c> 的位址類型。</span><span class="sxs-lookup"><span data-stu-id="2895d-146">The address types for <c>addr1</c>, <c>addr2</c>, and <c>addr3</c> using <see cref="T:System.Diagnostics.SymbolStore.SymAddressKind" />.</span></span></param>
        <param name="addr1"><span data-ttu-id="2895d-147">區域變數規格的第一個位址。</span><span class="sxs-lookup"><span data-stu-id="2895d-147">The first address for the local variable specification.</span></span></param>
        <param name="addr2"><span data-ttu-id="2895d-148">區域變數規格的第二個位址。</span><span class="sxs-lookup"><span data-stu-id="2895d-148">The second address for the local variable specification.</span></span></param>
        <param name="addr3"><span data-ttu-id="2895d-149">區域變數規格的第三個位址。</span><span class="sxs-lookup"><span data-stu-id="2895d-149">The third address for the local variable specification.</span></span></param>
        <param name="startOffset"><span data-ttu-id="2895d-150">變數的起始位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-150">The start offset for the variable.</span></span> <span data-ttu-id="2895d-151">如果為零，這個參數會被忽略，而且會在整個範圍中定義變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-151">If zero, this parameter is ignored and the variable is defined throughout the entire scope.</span></span> <span data-ttu-id="2895d-152">如果為非零，它會落在目前範圍的位移之內。</span><span class="sxs-lookup"><span data-stu-id="2895d-152">If nonzero, it falls within the offsets of the current scope.</span></span></param>
        <param name="endOffset"><span data-ttu-id="2895d-153">變數的結束位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-153">The end offset for the variable.</span></span> <span data-ttu-id="2895d-154">如果為零，這個參數會被忽略，而且會在整個範圍中定義變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-154">If zero, this parameter is ignored and the variable is defined throughout the entire scope.</span></span> <span data-ttu-id="2895d-155">如果為非零，它會落在目前範圍的位移之內。</span><span class="sxs-lookup"><span data-stu-id="2895d-155">If nonzero, it falls within the offsets of the current scope.</span></span></param>
        <summary><span data-ttu-id="2895d-156">在目前的語彙範圍中定義單一變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-156">Defines a single variable in the current lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-157">`startOffset`和`endOffset`參數是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="2895d-157">The `startOffset` and `endOffset` parameters are optional.</span></span> <span data-ttu-id="2895d-158">如果其值為零，則會予以忽略，並會在整個範圍中定義變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-158">If their value is zero, they are ignored and the variable is defined throughout the entire scope.</span></span> <span data-ttu-id="2895d-159">如果其值為非零，其會落在目前的範圍的位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-159">If their value is nonzero, they fall within the offsets of the current scope.</span></span>  
  
 <span data-ttu-id="2895d-160">您可以呼叫<xref:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable%2A>多次的不同範圍的位移範圍中出現多個相同名稱的變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-160">You can call <xref:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable%2A> multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope.</span></span> <span data-ttu-id="2895d-161">（在此情況下，開始和結束位移不能重疊。）</span><span class="sxs-lookup"><span data-stu-id="2895d-161">(In this case, start and end offsets must not overlap.)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public virtual void DefineParameter (string name, System.Reflection.ParameterAttributes attributes, int sequence, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineParameter(string name, valuetype System.Reflection.ParameterAttributes attributes, int32 sequence, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineParameter (name As String, attributes As ParameterAttributes, sequence As Integer, addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineParameter(System::String ^ name, System::Reflection::ParameterAttributes attributes, int sequence, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="sequence" Type="System.Int32" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2895d-162">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-162">This parameter is not used.</span></span></param>
        <param name="attributes"><span data-ttu-id="2895d-163">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-163">This parameter is not used.</span></span></param>
        <param name="sequence"><span data-ttu-id="2895d-164">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-164">This parameter is not used.</span></span></param>
        <param name="addrKind"><span data-ttu-id="2895d-165">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-165">This parameter is not used.</span></span></param>
        <param name="addr1"><span data-ttu-id="2895d-166">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-166">This parameter is not used.</span></span></param>
        <param name="addr2"><span data-ttu-id="2895d-167">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-167">This parameter is not used.</span></span></param>
        <param name="addr3"><span data-ttu-id="2895d-168">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-168">This parameter is not used.</span></span></param>
        <summary><span data-ttu-id="2895d-169">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-169">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2895d-170">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="2895d-170">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineSequencePoints">
      <MemberSignature Language="C#" Value="public virtual void DefineSequencePoints (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineSequencePoints(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32[] offsets, int32[] lines, int32[] columns, int32[] endLines, int32[] endColumns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineSequencePoints (document As ISymbolDocumentWriter, offsets As Integer(), lines As Integer(), columns As Integer(), endLines As Integer(), endColumns As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineSequencePoints(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, cli::array &lt;int&gt; ^ offsets, cli::array &lt;int&gt; ^ lines, cli::array &lt;int&gt; ^ columns, cli::array &lt;int&gt; ^ endLines, cli::array &lt;int&gt; ^ endColumns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="offsets" Type="System.Int32[]" />
        <Parameter Name="lines" Type="System.Int32[]" />
        <Parameter Name="columns" Type="System.Int32[]" />
        <Parameter Name="endLines" Type="System.Int32[]" />
        <Parameter Name="endColumns" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="2895d-171">要為其定義序列點的文件物件。</span><span class="sxs-lookup"><span data-stu-id="2895d-171">The document object for which the sequence points are being defined.</span></span></param>
        <param name="offsets"><span data-ttu-id="2895d-172">從方法的開頭進行測量之序列點的 IL 位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-172">The IL offset of the sequence points measured from the beginning of the method.</span></span></param>
        <param name="lines"><span data-ttu-id="2895d-173">序列點的起始行號。</span><span class="sxs-lookup"><span data-stu-id="2895d-173">The starting line numbers of the sequence points.</span></span></param>
        <param name="columns"><span data-ttu-id="2895d-174">序列點的起始欄號。</span><span class="sxs-lookup"><span data-stu-id="2895d-174">The starting column numbers of the sequence points.</span></span></param>
        <param name="endLines"><span data-ttu-id="2895d-175">序列點的結束行號。</span><span class="sxs-lookup"><span data-stu-id="2895d-175">The ending line numbers of the sequence points.</span></span></param>
        <param name="endColumns"><span data-ttu-id="2895d-176">序列點的結束欄號。</span><span class="sxs-lookup"><span data-stu-id="2895d-176">The ending column numbers of the sequence points.</span></span></param>
        <summary><span data-ttu-id="2895d-177">在目前的方法內定義一組序列點。</span><span class="sxs-lookup"><span data-stu-id="2895d-177">Defines a group of sequence points within the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-178">序列點用來對應原始程式檔位置與 IL 位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-178">Sequence points are used to map between source file locations and IL offsets.</span></span>  <span data-ttu-id="2895d-179">每個序列點 IL 位移和來源檔案指定的區域，相對的開始和結束行/資料行數字所組成<xref:System.Diagnostics.SymbolStore.ISymbolDocument>物件。</span><span class="sxs-lookup"><span data-stu-id="2895d-179">Each sequence point consists of an IL offset and source file region, specified by start and end line/column numbers relative to an <xref:System.Diagnostics.SymbolStore.ISymbolDocument> object.</span></span>  <span data-ttu-id="2895d-180">位於指定索引的每個陣列的每個項目會對應至特定的序列點。</span><span class="sxs-lookup"><span data-stu-id="2895d-180">Each element at a specific index of every array corresponds to a specific sequence point.</span></span> <span data-ttu-id="2895d-181">每一行和每個資料行定義方法內的陳述式的開始。</span><span class="sxs-lookup"><span data-stu-id="2895d-181">Each line and each column defines the start of a statement within a method.</span></span> <span data-ttu-id="2895d-182">應該排序陣列的位移遞增的順序。</span><span class="sxs-lookup"><span data-stu-id="2895d-182">The arrays should be sorted in the increasing order of offsets.</span></span> <span data-ttu-id="2895d-183">此位移為一律從方法，以位元組為單位的起始位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-183">The offset is always the offset from the start of the method, in bytes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public override sealed void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2895d-184">將 <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> 類別的目前執行個體所使用的資源釋出。</span><span class="sxs-lookup"><span data-stu-id="2895d-184">Releases the resources used by the current instance of the <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool A_0);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool A_0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (A_0 As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool A_0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="A_0" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="A_0">
          <span data-ttu-id="2895d-185"><see langword="true" /> 表示釋出 Managed 和 Unmanaged 資源，<see langword="false" /> 表示只釋出 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="2895d-185"><see langword="true" /> to release managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="2895d-186">由 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" /> 和 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" /> 方法呼叫，以釋出 <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> 類別之目前執行個體所使用的 Managed 和 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="2895d-186">Called by the <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" /> and <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" /> methods to release the managed and unmanaged resources used by the current instance of the <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-187">會呼叫這個方法只由公用<xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A>和<xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A>方法。 請勿直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-187">This method is called only by the public <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A> and <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A> methods; do not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SymWriter ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2895d-188">釋出 Unmanaged 資源並執行其他清除作業後，記憶體回收才能重新回收 <see cref="T:System.Diagnostics.SymbolStore.SymWriter" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-188">Releases unmanaged resources and performs other cleanup operations before the <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-189">這個方法會覆寫<xref:System.Object.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="2895d-189">This method overrides  <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="2895d-190">應用程式程式碼不應該呼叫這個方法。物件的`Finalize`方法會自動叫用記憶體回收期間，除非已停用記憶體回收行程的最終處理的呼叫所<xref:System.GC.SuppressFinalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-190">Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.Private.ISymUnmanagedWriter* GetWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.SymbolStore.Private.ISymUnmanagedWriter* GetWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.GetWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::Private::ISymUnmanagedWriter* GetWriter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.Private.ISymUnmanagedWriter*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public virtual void Initialize (IntPtr emitter, string filename, bool fFullBuild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Initialize(native int emitter, string filename, bool fFullBuild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Initialize(System.IntPtr,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Initialize (emitter As IntPtr, filename As String, fFullBuild As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Initialize(IntPtr emitter, System::String ^ filename, bool fFullBuild);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="emitter" Type="System.IntPtr" />
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="fFullBuild" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="emitter"><span data-ttu-id="2895d-191">中繼資料發出器介面。</span><span class="sxs-lookup"><span data-stu-id="2895d-191">The metadata emitter interface.</span></span></param>
        <param name="filename"><span data-ttu-id="2895d-192">偵錯符號寫入的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="2895d-192">The file name for which the debugging symbols are written.</span></span> <span data-ttu-id="2895d-193">有些寫入器需要檔案名稱，有些則不用。</span><span class="sxs-lookup"><span data-stu-id="2895d-193">Some writers require a file name, while others do not.</span></span> <span data-ttu-id="2895d-194">如果檔案名稱是指定給不使用檔案名稱的寫入器，則這個參數會被忽略。</span><span class="sxs-lookup"><span data-stu-id="2895d-194">If a file name is specified for a writer that does not use file names, this parameter is ignored.</span></span></param>
        <param name="fFullBuild">
          <span data-ttu-id="2895d-195"><see langword="true" /> 表示這是完整重建，<see langword="false" /> 則表示這是累加編譯。</span><span class="sxs-lookup"><span data-stu-id="2895d-195"><see langword="true" /> indicates that this is a full rebuild; <see langword="false" /> indicates an incremental compilation.</span></span></param>
        <summary><span data-ttu-id="2895d-196">設定要與這個寫入器相關聯的中繼資料發出器介面。</span><span class="sxs-lookup"><span data-stu-id="2895d-196">Sets the metadata emitter interface to associate with this writer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-197"><xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> 也會設定輸出檔名稱的偵錯符號寫入的位置。</span><span class="sxs-lookup"><span data-stu-id="2895d-197"><xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> also sets the output file name where the debugging symbols are written.</span></span> <span data-ttu-id="2895d-198">這個方法可以呼叫一次，必須在呼叫任何其他寫入器方法會呼叫之前。</span><span class="sxs-lookup"><span data-stu-id="2895d-198">This method can be called only once and must be called before any other writer methods are called.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2895d-199">提供存取 unmanaged 程式碼的能力。</span><span class="sxs-lookup"><span data-stu-id="2895d-199">for the ability to access unmanaged code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InitWriter">
      <MemberSignature Language="C#" Value="public void InitWriter (bool noUnderlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InitWriter(bool noUnderlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.InitWriter(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InitWriter (noUnderlyingWriter As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InitWriter(bool noUnderlyingWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noUnderlyingWriter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noUnderlyingWriter">
          <span data-ttu-id="2895d-200">如果基礎符號寫入器將透過呼叫 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> 方法來提供，則為 <see langword="true" />；如果應該建立預設基礎符號寫入器，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-200"><see langword="true" /> if an underlying symbol writer will be provided by calling the <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> method; <see langword="false" /> if a default underlying symbol writer should be created instead.</span></span></param>
        <summary><span data-ttu-id="2895d-201">初始化符號寫入器。</span><span class="sxs-lookup"><span data-stu-id="2895d-201">Initializes the symbol writer.</span></span> <span data-ttu-id="2895d-202">您不應該直接呼叫這個方法，它是由建構函式所呼叫。</span><span class="sxs-lookup"><span data-stu-id="2895d-202">This method should not be called directly; it is called by the constructor.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2895d-203">提供存取 unmanaged 程式碼的能力。</span><span class="sxs-lookup"><span data-stu-id="2895d-203">for the ability to access unmanaged code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenMethod">
      <MemberSignature Language="C#" Value="public virtual void OpenMethod (System.Diagnostics.SymbolStore.SymbolToken method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenMethod(valuetype System.Diagnostics.SymbolStore.SymbolToken method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OpenMethod (method As SymbolToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OpenMethod(System::Diagnostics::SymbolStore::SymbolToken method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Diagnostics.SymbolStore.SymbolToken" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="2895d-204">要開啟之方法的中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="2895d-204">The metadata token for the method to be opened.</span></span></param>
        <summary><span data-ttu-id="2895d-205">開啟要置入符號資訊的方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-205">Opens a method in which to place symbol information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-206">指定的方法會變成目前的方法呼叫來定義序列點、 參數和語彙範圍。</span><span class="sxs-lookup"><span data-stu-id="2895d-206">The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes.</span></span> <span data-ttu-id="2895d-207">沒有隱含的語彙範圍整個方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-207">There is an implicit lexical scope around the entire method.</span></span> <span data-ttu-id="2895d-208">重新開啟先前未關閉的方法，會清除任何先前定義的符號的方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-208">Reopening a method that has been previously closed erases any previously defined symbols for the method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNamespace">
      <MemberSignature Language="C#" Value="public virtual void OpenNamespace (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenNamespace(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OpenNamespace (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OpenNamespace(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="2895d-209">新命名空間名稱。</span><span class="sxs-lookup"><span data-stu-id="2895d-209">The name of the new namespace.</span></span></param>
        <summary><span data-ttu-id="2895d-210">開啟新的命名空間。</span><span class="sxs-lookup"><span data-stu-id="2895d-210">Opens a new namespace.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-211">定義在命名空間中存在的方法或變數之前呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-211">Call this method before defining methods or variables that exist within a namespace.</span></span> <span data-ttu-id="2895d-212">可以是巢狀命名空間。</span><span class="sxs-lookup"><span data-stu-id="2895d-212">Namespaces can be nested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenScope">
      <MemberSignature Language="C#" Value="public virtual int OpenScope (int startOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 OpenScope(int32 startOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenScope (startOffset As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int OpenScope(int startOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startOffset"><span data-ttu-id="2895d-213">從方法開頭到語彙範圍中第一個指令的 IL 位移 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="2895d-213">The IL offset in bytes from the beginning of the method to the first instruction in the lexical scope.</span></span></param>
        <summary><span data-ttu-id="2895d-214">開啟目前方法中的新語彙範圍。</span><span class="sxs-lookup"><span data-stu-id="2895d-214">Opens a new lexical scope in the current method.</span></span></summary>
        <returns><span data-ttu-id="2895d-215">不透明範圍識別項，稍後可以與 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" /> 一起用來定義範圍的起始和結束位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-215">An opaque scope identifier that can be used with <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" /> to define the start and end offsets of a scope at a later time.</span></span> <span data-ttu-id="2895d-216">在這種情況下，傳遞到 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> 和 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" /> 的位移會被忽略。</span><span class="sxs-lookup"><span data-stu-id="2895d-216">In this case, the offsets passed to <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> and <see cref="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" /> are ignored.</span></span> <span data-ttu-id="2895d-217">範圍識別項只有在目前方法中才會有效。</span><span class="sxs-lookup"><span data-stu-id="2895d-217">A scope identifier is valid only in the current method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-218">這個範圍會變成新的目前範圍，並且推送至堆疊的範圍。</span><span class="sxs-lookup"><span data-stu-id="2895d-218">This scope becomes the new current scope and is pushed onto a stack of scopes.</span></span> <span data-ttu-id="2895d-219">範圍必須形成階層。</span><span class="sxs-lookup"><span data-stu-id="2895d-219">Scopes must form a hierarchy.</span></span> <span data-ttu-id="2895d-220">同層級不允許重疊。</span><span class="sxs-lookup"><span data-stu-id="2895d-220">Siblings are not allowed to overlap.</span></span>  
  
 <span data-ttu-id="2895d-221">範圍識別項，才有效目前方法中。</span><span class="sxs-lookup"><span data-stu-id="2895d-221">Scope identifiers are only valid in the current method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMethodSourceRange">
      <MemberSignature Language="C#" Value="public virtual void SetMethodSourceRange (System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int startLine, int startColumn, System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMethodSourceRange(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int32 startLine, int32 startColumn, class System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMethodSourceRange (startDoc As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endDoc As ISymbolDocumentWriter, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMethodSourceRange(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ startDoc, int startLine, int startColumn, System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ endDoc, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDoc" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endDoc" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startDoc"><span data-ttu-id="2895d-222">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-222">This parameter is not used.</span></span></param>
        <param name="startLine"><span data-ttu-id="2895d-223">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-223">This parameter is not used.</span></span></param>
        <param name="startColumn"><span data-ttu-id="2895d-224">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-224">This parameter is not used.</span></span></param>
        <param name="endDoc"><span data-ttu-id="2895d-225">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-225">This parameter is not used.</span></span></param>
        <param name="endLine"><span data-ttu-id="2895d-226">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-226">This parameter is not used.</span></span></param>
        <param name="endColumn"><span data-ttu-id="2895d-227">不使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="2895d-227">This parameter is not used.</span></span></param>
        <summary><span data-ttu-id="2895d-228">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="2895d-228">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2895d-229">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="2895d-229">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetScopeRange">
      <MemberSignature Language="C#" Value="public virtual void SetScopeRange (int scopeID, int startOffset, int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetScopeRange(int32 scopeID, int32 startOffset, int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetScopeRange (scopeID As Integer, startOffset As Integer, endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeID" Type="System.Int32" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scopeID"><span data-ttu-id="2895d-230">由 <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> 方法所傳回之語彙範圍的識別項。</span><span class="sxs-lookup"><span data-stu-id="2895d-230">The identifier of the lexical scope returned by the <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> method.</span></span></param>
        <param name="startOffset"><span data-ttu-id="2895d-231">語彙範圍開頭的 IL 位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-231">The IL offset of the beginning of the lexical scope.</span></span></param>
        <param name="endOffset"><span data-ttu-id="2895d-232">語彙範圍結尾的 IL 位移。</span><span class="sxs-lookup"><span data-stu-id="2895d-232">The IL offset of the end of the lexical scope.</span></span></param>
        <summary><span data-ttu-id="2895d-233">定義指定語彙範圍的位移範圍。</span><span class="sxs-lookup"><span data-stu-id="2895d-233">Defines the offset range for the specified lexical scope.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSymAttribute">
      <MemberSignature Language="C#" Value="public virtual void SetSymAttribute (System.Diagnostics.SymbolStore.SymbolToken parent, string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetSymAttribute(valuetype System.Diagnostics.SymbolStore.SymbolToken parent, string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetSymAttribute (parent As SymbolToken, name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetSymAttribute(System::Diagnostics::SymbolStore::SymbolToken parent, System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Diagnostics.SymbolStore.SymbolToken" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="parent"><span data-ttu-id="2895d-234">要為其定義屬性的中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="2895d-234">The metadata token for which the attribute is being defined.</span></span></param>
        <param name="name"><span data-ttu-id="2895d-235">屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="2895d-235">The attribute name.</span></span></param>
        <param name="data"><span data-ttu-id="2895d-236">屬性值。</span><span class="sxs-lookup"><span data-stu-id="2895d-236">The attribute value.</span></span></param>
        <summary><span data-ttu-id="2895d-237">在指定屬性名稱和屬性值時定義屬性。</span><span class="sxs-lookup"><span data-stu-id="2895d-237">Defines an attribute when given the attribute name and the attribute value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-238"><xref:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute%2A>方法僅符號資訊相關聯，而且不是中繼資料的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="2895d-238">The <xref:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute%2A> method is only associated with symbolic information and is not a metadata custom attribute.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetUnderlyingWriter">
      <MemberSignature Language="C#" Value="public virtual void SetUnderlyingWriter (IntPtr underlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetUnderlyingWriter(native int underlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetUnderlyingWriter (underlyingWriter As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetUnderlyingWriter(IntPtr underlyingWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingWriter" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="underlyingWriter"><span data-ttu-id="2895d-239">程式碼的 <see cref="T:System.IntPtr" /> 類型指標，這是基礎寫入器。</span><span class="sxs-lookup"><span data-stu-id="2895d-239">An <see cref="T:System.IntPtr" /> type pointer to code that is the underlying writer.</span></span></param>
        <summary><span data-ttu-id="2895d-240">設定 Managed <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> 用來發出符號的基礎 [ISymUnmanagedWriter Interface](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) 介面 (對應的 Unmanaged API)。</span><span class="sxs-lookup"><span data-stu-id="2895d-240">Sets the underlying [ISymUnmanagedWriter Interface](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) (the corresponding unmanaged API) that a managed <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> uses to emit symbols.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-241">基礎[ISymUnmanagedWriter 介面](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md)(對應的 unmanaged 應用程式開發介面) 介面代表 managed 程式碼的符號寫入器。</span><span class="sxs-lookup"><span data-stu-id="2895d-241">The underlying [ISymUnmanagedWriter Interface](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) (the corresponding unmanaged API) interface represents a symbol writer for managed code.</span></span> <span data-ttu-id="2895d-242">介面會提供方法來定義文件，序列點、 語彙範圍和變數。</span><span class="sxs-lookup"><span data-stu-id="2895d-242">The interface provides methods to define documents, sequence points, lexical scopes, and variables.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2895d-243">提供存取 unmanaged 程式碼的能力。</span><span class="sxs-lookup"><span data-stu-id="2895d-243">for the ability to access unmanaged code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public virtual void SetUserEntryPoint (System.Diagnostics.SymbolStore.SymbolToken entryMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetUserEntryPoint(valuetype System.Diagnostics.SymbolStore.SymbolToken entryMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetUserEntryPoint (entryMethod As SymbolToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetUserEntryPoint(System::Diagnostics::SymbolStore::SymbolToken entryMethod);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Diagnostics.SymbolStore.SymbolToken" />
      </Parameters>
      <Docs>
        <param name="entryMethod"><span data-ttu-id="2895d-244">方法的中繼資料語彙基元，這是使用者進入點。</span><span class="sxs-lookup"><span data-stu-id="2895d-244">The metadata token for the method that is the user entry point.</span></span></param>
        <summary><span data-ttu-id="2895d-245">識別使用者定義的方法做為目前模組的進入點。</span><span class="sxs-lookup"><span data-stu-id="2895d-245">Identifies the user-defined method as the entry point for the current module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-246">這通常是主要的方法。</span><span class="sxs-lookup"><span data-stu-id="2895d-246">This is normally the main method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string fullName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string fullName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (fullName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ fullName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullName"><span data-ttu-id="2895d-247">命名空間的完整名稱。</span><span class="sxs-lookup"><span data-stu-id="2895d-247">The fully qualified name of the namespace.</span></span></param>
        <summary><span data-ttu-id="2895d-248">指定是在開放式語彙範圍內使用指定且完整的命名空間名稱。</span><span class="sxs-lookup"><span data-stu-id="2895d-248">Specifies that the given, fully qualified namespace name is used within the open lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2895d-249">關閉目前的範圍，可防止這個範圍內使用命名空間。</span><span class="sxs-lookup"><span data-stu-id="2895d-249">Closing the current scope prevents this scope from using the namespace.</span></span> <span data-ttu-id="2895d-250">命名空間中保持使用中的所有領域都繼承自目前開啟的範圍。</span><span class="sxs-lookup"><span data-stu-id="2895d-250">The namespace remains in use in all scopes that inherit from the current open scope.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>