<Type Name="ReliableSessionBindingElement" FullName="System.ServiceModel.Channels.ReliableSessionBindingElement">
  <TypeSignature Language="C#" Value="public sealed class ReliableSessionBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReliableSessionBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReliableSessionBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReliableSessionBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="36f12-101">表示繫結項目，此繫結項目可以產生端點之間之可靠工作階段所需要的傳送和接收通道。</span><span class="sxs-lookup"><span data-stu-id="36f12-101">Represents the binding element that can produce the sending and receiving channels required for a reliable session between endpoints.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-102">提供工作階段，並選擇性地提供已排序的訊息傳遞。</span><span class="sxs-lookup"><span data-stu-id="36f12-102">Provides sessions and optionally provides ordered message delivery.</span></span> <span data-ttu-id="36f12-103">這個實作的工作階段可以跨 SOAP 和傳輸媒介。</span><span class="sxs-lookup"><span data-stu-id="36f12-103">This implemented session can cross SOAP and transport intermediaries.</span></span>  
  
 <span data-ttu-id="36f12-104">每個繫結項目都代表傳送或接收訊息時的一個處理步驟。</span><span class="sxs-lookup"><span data-stu-id="36f12-104">Each binding element represents a processing step when sending or receiving messages.</span></span> <span data-ttu-id="36f12-105">繫結項目會在執行階段建立通道處理站和接聽程式，它們是在傳送和接收訊息時所需要之傳出和傳入通道堆疊的必要建置項目。</span><span class="sxs-lookup"><span data-stu-id="36f12-105">At runtime, binding elements create the channel factories and listeners that are necessary to build outgoing and incoming channel stacks required to send and receive messages.</span></span> <span data-ttu-id="36f12-106"><xref:System.ServiceModel.Channels.ReliableSessionBindingElement> 在堆疊中提供選擇性的層級，而透過該層級可以在端點之間建立可靠工作階段，並設定這個工作階段的行為。</span><span class="sxs-lookup"><span data-stu-id="36f12-106">The <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> provides an optional layer in the stack that can establish a reliable session between endpoints and configure the behavior of this session.</span></span>  
  
 <span data-ttu-id="36f12-107"><xref:System.ServiceModel.Channels.ReliableSessionBindingElement> 會在下表中的標準繫結上提供。</span><span class="sxs-lookup"><span data-stu-id="36f12-107">The <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> is provided on the standard bindings in the following table.</span></span>  
  
|<span data-ttu-id="36f12-108">繫結</span><span class="sxs-lookup"><span data-stu-id="36f12-108">Binding</span></span>|<span data-ttu-id="36f12-109">預設</span><span class="sxs-lookup"><span data-stu-id="36f12-109">Default</span></span>|  
|-------------|-------------|  
|<xref:System.ServiceModel.NetTcpBinding>|<span data-ttu-id="36f12-110">Off</span><span class="sxs-lookup"><span data-stu-id="36f12-110">Off</span></span>|  
|<xref:System.ServiceModel.WSHttpBinding>|<span data-ttu-id="36f12-111">Off</span><span class="sxs-lookup"><span data-stu-id="36f12-111">Off</span></span>|  
|<xref:System.ServiceModel.WSDualHttpBinding>|<span data-ttu-id="36f12-112">開啟 (必要)</span><span class="sxs-lookup"><span data-stu-id="36f12-112">On (required)</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="36f12-113"><xref:System.ServiceModel.Channels.ReliableSessionBindingElement> 可以加入至任何自訂繫結。</span><span class="sxs-lookup"><span data-stu-id="36f12-113">The <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> can be added to any custom binding.</span></span> <span data-ttu-id="36f12-114">這個動作會由下列組態項目完成。</span><span class="sxs-lookup"><span data-stu-id="36f12-114">This is done using the following configuration elements.</span></span>  
  
```  
<bindings>  
    <customBinding>  
        <binding configurationName="ReliabilityHTTP">  
            <reliableSession/>  
        </binding>  
    </customBinding>  
</bindings>  
```  
  
 <span data-ttu-id="36f12-115">下列範例程式碼將示範如何透過程式碼來使用 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement>。</span><span class="sxs-lookup"><span data-stu-id="36f12-115">The following sample code demonstrates how to use <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> in code.</span></span>  
  
 [!code-csharp[S_Imperative#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_imperative/cs/service.cs#1)]
 [!code-vb[S_Imperative#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_imperative/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="36f12-116">初始化 <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="36f12-116">Initializes a new instance of the <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="36f12-117">初始化 <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="36f12-117">Initializes a new instance of the <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement (bool ordered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool ordered) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ordered As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement(bool ordered);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ordered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ordered">
          <span data-ttu-id="36f12-118">如果訊息必須按照其傳送的順序傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-118"><see langword="true" /> if messages must be delivered in the order in which they are sent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="36f12-119">預設值是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-119">The default value is <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="36f12-120">初始化 <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> 類別的新執行個體，該執行個體會指定訊息傳遞是否必須保留訊息傳送時的順序。</span><span class="sxs-lookup"><span data-stu-id="36f12-120">Initializes a new instance of the <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> class that specifies whether message delivery must preserve the order in which messages are sent.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcknowledgementInterval">
      <MemberSignature Language="C#" Value="public TimeSpan AcknowledgementInterval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AcknowledgementInterval" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgementInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AcknowledgementInterval { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-121">取得或設定傳送確認到可靠通道 (由處理站所建立) 之訊息來源前，目的端需等候的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="36f12-121">Gets or sets the interval of time that a destination waits before sending an acknowledgment to the message source on reliable channels that are created by the factory.</span></span></summary>
        <value><span data-ttu-id="36f12-122"><see cref="T:System.TimeSpan" />，指定服務等候直到認可傳送至訊息來源的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="36f12-122">The <see cref="T:System.TimeSpan" /> that specifies the interval of time that a service waits until sending an acknowledgment to the message source.</span></span> <span data-ttu-id="36f12-123">預設值是 2 秒。</span><span class="sxs-lookup"><span data-stu-id="36f12-123">The default value is 2 seconds.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-124">接收可靠通道上訊息的目的地會將這些訊息的認可組成單一訊息，以便減少網路流量並增加訊息的資訊密度。</span><span class="sxs-lookup"><span data-stu-id="36f12-124">The destination that receives messages on a reliable channel groups the acknowledgments for these messages together into a single message to reduce network traffic and to increase information density on messages.</span></span> <span data-ttu-id="36f12-125">當流量增加時，分組規模會更好。</span><span class="sxs-lookup"><span data-stu-id="36f12-125">Grouping scales better as traffic increases.</span></span> <span data-ttu-id="36f12-126">它不會在一收到各個訊息時就立即嘗試傳送認可，而是等候一段時間，將在該時間間隔內到達的認可組成群組，然後再一起傳送。</span><span class="sxs-lookup"><span data-stu-id="36f12-126">It does not attempt to send an acknowledgment for every message it receives as soon as possible, but rather waits for an interval of time, groups together the acknowledgments that have arrived during that interval, and then sends them all together.</span></span> <span data-ttu-id="36f12-127">所收到的第一個訊息是例外狀況，它便會在傳遞之後立刻進行認可。</span><span class="sxs-lookup"><span data-stu-id="36f12-127">The first message that is received is the exception; it is acknowledged as soon as it is delivered.</span></span> <span data-ttu-id="36f12-128">另外，如果可靠工作階段是搭配單一 HTTP 連線使用，例如搭配 <xref:System.ServiceModel.WSHttpBinding> 而非 <xref:System.ServiceModel.WSDualHttpBinding>，就不會使用這個設定。</span><span class="sxs-lookup"><span data-stu-id="36f12-128">Also, if reliable sessions are used with single HTTP connections, as is the case for example with the <xref:System.ServiceModel.WSHttpBinding> but not <xref:System.ServiceModel.WSDualHttpBinding>, then this setting is not used.</span></span>  
  
 <span data-ttu-id="36f12-129">使用 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A> 屬性設定的值為基礎結構的建議，而不是硬性限制。</span><span class="sxs-lookup"><span data-stu-id="36f12-129">The value that is set with the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A> property is a recommendation to the infrastructure and not a hard limit.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="36f12-130">設定的值小於或等於零。</span><span class="sxs-lookup"><span data-stu-id="36f12-130">The value set is less than or equal to zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel"><span data-ttu-id="36f12-131">處理站建置之通道的型別。</span><span class="sxs-lookup"><span data-stu-id="36f12-131">The type of channel the factory builds.</span></span></typeparam>
        <param name="context"><span data-ttu-id="36f12-132"><see cref="T:System.ServiceModel.Channels.BindingContext" />，其中包含建置可產生類型 <c>TChannel</c> 通道之處理站時的必要資訊。</span><span class="sxs-lookup"><span data-stu-id="36f12-132">The <see cref="T:System.ServiceModel.Channels.BindingContext" /> that contains the information required to build the factories that can produce channels of type <c>TChannel</c>.</span></span></param>
        <summary><span data-ttu-id="36f12-133">傳回處理站，該處理站會建立支援可靠工作階段之指定型別的通道。</span><span class="sxs-lookup"><span data-stu-id="36f12-133">Returns a factory that creates a channel of a specified type that supports a reliable session.</span></span></summary>
        <returns><span data-ttu-id="36f12-134">型別 <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> 的 <see cref="T:System.ServiceModel.Channels.IChannel" />，是從 <paramref name="context" />初始化的。</span><span class="sxs-lookup"><span data-stu-id="36f12-134">A <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> of type <see cref="T:System.ServiceModel.Channels.IChannel" /> initialized from the <paramref name="context" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-135">由處理站所產生的 <xref:System.ServiceModel.Channels.IChannel> 屬於型別 `TChannel`。</span><span class="sxs-lookup"><span data-stu-id="36f12-135">The <xref:System.ServiceModel.Channels.IChannel> produced by the factory is of type `TChannel`.</span></span> <span data-ttu-id="36f12-136">用戶端上支援的 `TChannel` 型別與連接至服務之基礎通道型別相依。</span><span class="sxs-lookup"><span data-stu-id="36f12-136">The types of `TChannel` supported on the client is dependent of the types of underlying channels that connect to the service.</span></span> <span data-ttu-id="36f12-137">下表指出支援提供基礎通道功能的可靠工作階段通道型別。</span><span class="sxs-lookup"><span data-stu-id="36f12-137">The following table indicates what reliable session channel types are supported as a function of the underlying channels.</span></span>  
  
|<span data-ttu-id="36f12-138">基礎通道型別支援的可靠工作階段 `TChannel` 型別</span><span class="sxs-lookup"><span data-stu-id="36f12-138">Support for Reliable Session `TChannel` Types by Underlying Channel Types</span></span>|<span data-ttu-id="36f12-139">IRequestChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-139">IRequestChannel</span></span>|<span data-ttu-id="36f12-140">IRequestSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-140">IRequestSessionChannel</span></span>|<span data-ttu-id="36f12-141">IDuplexChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-141">IDuplexChannel</span></span>|<span data-ttu-id="36f12-142">IDuplexSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-142">IDuplexSessionChannel</span></span>|  
|-------------------------------------------------------------------------------|---------------------|----------------------------|--------------------|---------------------------|  
|<span data-ttu-id="36f12-143">IOutputSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-143">IOutputSessionChannel</span></span>|<span data-ttu-id="36f12-144">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-144">Yes</span></span>|<span data-ttu-id="36f12-145">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-145">Yes</span></span>|<span data-ttu-id="36f12-146">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-146">Yes</span></span>|<span data-ttu-id="36f12-147">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-147">Yes</span></span>|  
|<span data-ttu-id="36f12-148">IRequestSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-148">IRequestSessionChannel</span></span>|<span data-ttu-id="36f12-149">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-149">Yes</span></span>|<span data-ttu-id="36f12-150">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-150">Yes</span></span>|<span data-ttu-id="36f12-151">否</span><span class="sxs-lookup"><span data-stu-id="36f12-151">No</span></span>|<span data-ttu-id="36f12-152">否</span><span class="sxs-lookup"><span data-stu-id="36f12-152">No</span></span>|  
|<span data-ttu-id="36f12-153">IDuplexSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-153">IDuplexSessionChannel</span></span>|<span data-ttu-id="36f12-154">否</span><span class="sxs-lookup"><span data-stu-id="36f12-154">No</span></span>|<span data-ttu-id="36f12-155">否</span><span class="sxs-lookup"><span data-stu-id="36f12-155">No</span></span>|<span data-ttu-id="36f12-156">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-156">Yes</span></span>|<span data-ttu-id="36f12-157">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-157">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="36f12-158">不支援 <paramref name="TChannel" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-158"><paramref name="TChannel" /> is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel"><span data-ttu-id="36f12-159">已建置接聽程式要接受的 <see cref="T:System.ServiceModel.Channels.IChannel" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-159">The <see cref="T:System.ServiceModel.Channels.IChannel" /> that the listener is built to accept.</span></span></typeparam>
        <param name="context"><span data-ttu-id="36f12-160"><see cref="T:System.ServiceModel.Channels.BindingContext" />，其中包含建置可接受類型 <c>TChannel</c> 通道之接聽程式時的必要資訊。</span><span class="sxs-lookup"><span data-stu-id="36f12-160">The <see cref="T:System.ServiceModel.Channels.BindingContext" /> that contains the information required to build the listeners that can accept channels of type <c>TChannel</c>.</span></span></param>
        <summary><span data-ttu-id="36f12-161">傳回接聽程式，此接聽程式會接受支援可靠工作階段之指定型別的通道。</span><span class="sxs-lookup"><span data-stu-id="36f12-161">Returns a listener that accepts a channel of a specified type that supports a reliable session.</span></span></summary>
        <returns><span data-ttu-id="36f12-162"><see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> 型別的 <see cref="T:System.ServiceModel.Channels.IChannel" />，初始化自 <paramref name="context" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-162">The <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> of type <see cref="T:System.ServiceModel.Channels.IChannel" /> initialized from the <paramref name="context" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-163">接聽程式接受的 <xref:System.ServiceModel.Channels.IChannel> 屬於型別 `TChannel`。</span><span class="sxs-lookup"><span data-stu-id="36f12-163">The <xref:System.ServiceModel.Channels.IChannel> accepted by the listener is of type `TChannel`.</span></span> <span data-ttu-id="36f12-164">裝載服務之伺服器上支援的 `TChannel` 型別與用於連接至用戶端之基礎通道型別相依。</span><span class="sxs-lookup"><span data-stu-id="36f12-164">The types of `TChannel` supported on the server that hosts the service is dependent of the types of underlying channels used to connect to the client.</span></span> <span data-ttu-id="36f12-165">下表指出支援提供基礎通道功能的可靠工作階段通道型別。</span><span class="sxs-lookup"><span data-stu-id="36f12-165">The following table indicates what reliable session channel types are supported as a function of the underlying channels.</span></span>  
  
|<span data-ttu-id="36f12-166">基礎通道型別支援的可靠工作階段 `TChannel` 型別</span><span class="sxs-lookup"><span data-stu-id="36f12-166">Support for Reliable Session `TChannel` Types by Underlying Channel Types</span></span>|<span data-ttu-id="36f12-167">IReplyChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-167">IReplyChannel</span></span>|<span data-ttu-id="36f12-168">IReplySessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-168">IReplySessionChannel</span></span>|<span data-ttu-id="36f12-169">IDuplexChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-169">IDuplexChannel</span></span>|<span data-ttu-id="36f12-170">IDuplexSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-170">IDuplexSessionChannel</span></span>|  
|-------------------------------------------------------------------------------|-------------------|--------------------------|--------------------|---------------------------|  
|<span data-ttu-id="36f12-171">IInputSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-171">IInputSessionChannel</span></span>|<span data-ttu-id="36f12-172">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-172">Yes</span></span>|<span data-ttu-id="36f12-173">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-173">Yes</span></span>|<span data-ttu-id="36f12-174">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-174">Yes</span></span>|<span data-ttu-id="36f12-175">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-175">Yes</span></span>|  
|<span data-ttu-id="36f12-176">IReplySessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-176">IReplySessionChannel</span></span>|<span data-ttu-id="36f12-177">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-177">Yes</span></span>|<span data-ttu-id="36f12-178">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-178">Yes</span></span>|<span data-ttu-id="36f12-179">否</span><span class="sxs-lookup"><span data-stu-id="36f12-179">No</span></span>|<span data-ttu-id="36f12-180">否</span><span class="sxs-lookup"><span data-stu-id="36f12-180">No</span></span>|  
|<span data-ttu-id="36f12-181">IDuplexSessionChannel</span><span class="sxs-lookup"><span data-stu-id="36f12-181">IDuplexSessionChannel</span></span>|<span data-ttu-id="36f12-182">否</span><span class="sxs-lookup"><span data-stu-id="36f12-182">No</span></span>|<span data-ttu-id="36f12-183">否</span><span class="sxs-lookup"><span data-stu-id="36f12-183">No</span></span>|<span data-ttu-id="36f12-184">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-184">Yes</span></span>|<span data-ttu-id="36f12-185">[是]</span><span class="sxs-lookup"><span data-stu-id="36f12-185">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="36f12-186">不支援 <paramref name="TChannel" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-186"><paramref name="TChannel" /> is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel"><span data-ttu-id="36f12-187">處理站建置之通道的型別。</span><span class="sxs-lookup"><span data-stu-id="36f12-187">The type of channel the factory builds.</span></span></typeparam>
        <param name="context"><span data-ttu-id="36f12-188"><see cref="T:System.ServiceModel.Channels.BindingContext" />，其中包含建置可產生類型 <c>TChannel</c> 通道之處理站時的必要資訊。</span><span class="sxs-lookup"><span data-stu-id="36f12-188">The <see cref="T:System.ServiceModel.Channels.BindingContext" /> that contains the information required to build the factories that can produce channels of type <c>TChannel</c>.</span></span></param>
        <summary><span data-ttu-id="36f12-189">傳回值，這個值會指出是否可以為可支援可靠工作階段的通道和內容建置通道處理站。</span><span class="sxs-lookup"><span data-stu-id="36f12-189">Returns a value that indicates whether the channel factory can be built for the channel and context provided that can support a reliable session.</span></span></summary>
        <returns>
          <span data-ttu-id="36f12-190">如果可以建置型別 <paramref name="TChannel" /> 的 <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" />，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-190"><see langword="true" /> if the <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> of type <paramref name="TChannel" /> can be built; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-191">這個方法會根據 `true` 中所提供值的表格，為 `false` 傳回 `TChannel` 或 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>。</span><span class="sxs-lookup"><span data-stu-id="36f12-191">This method returns `true` or `false` for a `TChannel` in accordance with the table of values provided in <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel"><span data-ttu-id="36f12-192"><see cref="T:System.ServiceModel.Channels.IChannel" /> ，通道接聽程式，如果建置，可接受。</span><span class="sxs-lookup"><span data-stu-id="36f12-192">The <see cref="T:System.ServiceModel.Channels.IChannel" /> that the channel listener, if build, accepts.</span></span></typeparam>
        <param name="context"><span data-ttu-id="36f12-193"><see cref="T:System.ServiceModel.Channels.BindingContext" />，其中包含建置可接受類型 <c>TChannel</c> 通道之接聽程式時的必要資訊。</span><span class="sxs-lookup"><span data-stu-id="36f12-193">The <see cref="T:System.ServiceModel.Channels.BindingContext" /> that contains the information required to build the listeners that can accept channels of type <c>TChannel</c>.</span></span></param>
        <summary><span data-ttu-id="36f12-194">傳回值，這個值會指出是否可以為可支援可靠工作階段的通道和內容建置通道接聽程式。</span><span class="sxs-lookup"><span data-stu-id="36f12-194">Returns a value that indicates whether the channel listener can be built for the channel and context provided that can support a reliable session.</span></span></summary>
        <returns>
          <span data-ttu-id="36f12-195">如果可以由繫結項目建置可以產生型別 <see langword="true" /> 之 <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" /> 的 <see cref="T:System.ServiceModel.Channels.IChannel" />，則為 <paramref name="TChannel" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-195"><see langword="true" /> if the <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" /> that can produce an <see cref="T:System.ServiceModel.Channels.IChannel" /> of type <paramref name="TChannel" /> can be built by the binding element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-196">通道堆疊通常是使用處理站模式所建立，在此種模式中，繫結程序會建立通道堆疊。</span><span class="sxs-lookup"><span data-stu-id="36f12-196">Channel stacks are typically created using a factory pattern where a binding creates the channel stack.</span></span> <span data-ttu-id="36f12-197">當傳送訊息時，繫結會使來建置通道處理站，而此處理站會接著建置通道堆疊，並傳回在堆疊中頂端通道的參考。</span><span class="sxs-lookup"><span data-stu-id="36f12-197">When sending messages, a binding is used to build a channel factory which in turn builds a channel stack and returns a reference to the top channel in the stack.</span></span> <span data-ttu-id="36f12-198">應用程式可以接著使用這個通道來傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-198">The application can then use this channel to send messages.</span></span> <span data-ttu-id="36f12-199">同樣地，當接收訊息時，繫結會用來建置通道接聽程式，以便接聽傳入的訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-199">Similarly when receiving messages, a binding is used to build a channel listener which listens for incoming messages.</span></span> <span data-ttu-id="36f12-200">此通道接聽程式會會透過建立通道堆疊並將應用程式參考傳遞至頂端通道的方式，來提供訊息給接聽應用程式。</span><span class="sxs-lookup"><span data-stu-id="36f12-200">The channel listener provides messages to the listening application by creating channel stacks and handing the application a reference to the top channel.</span></span>  
  
 <span data-ttu-id="36f12-201">這個方法會根據 `true` 中所提供值的表格，為 `false` 傳回 `TChannel` 或 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>。</span><span class="sxs-lookup"><span data-stu-id="36f12-201">This method returns `true` or `false` for a `TChannel` in accordance with the table of values provided in <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="36f12-202">建立目前可靠工作階段繫結項目的複本。</span><span class="sxs-lookup"><span data-stu-id="36f12-202">Creates a copy of the current reliable session binding element.</span></span></summary>
        <returns><span data-ttu-id="36f12-203">做為目前繫結項目之複製品的 <see cref="T:System.ServiceModel.Channels.BindingElement" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-203">A <see cref="T:System.ServiceModel.Channels.BindingElement" /> that is a clone of the current binding element.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowControlEnabled">
      <MemberSignature Language="C#" Value="public bool FlowControlEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlowControlEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowControlEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FlowControlEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-204">取得或設定值，這個值會指出可靠工作階段是否已啟用流量控制。</span><span class="sxs-lookup"><span data-stu-id="36f12-204">Gets or sets a value that indicates whether the reliable session has flow control enabled.</span></span></summary>
        <value>
          <span data-ttu-id="36f12-205">如果可靠工作階段已啟用流量控制，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-205"><see langword="true" /> if the reliable session has flow control enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="36f12-206">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-206">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-207">流量控制是可靠工作階段實作的機制，它可確保傳送者所傳送的訊息不會超過接收者可處理的數量。</span><span class="sxs-lookup"><span data-stu-id="36f12-207">Flow control is a mechanism that reliable sessions implement to ensure that senders do not send more messages than a receiver can handle.</span></span> <span data-ttu-id="36f12-208">接收者所擁有的訊息緩衝區，會用來調節訊息高載或不按照順序的訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-208">Receivers have a buffer of messages that is used to accommodate message bursts and out-of-order messages.</span></span> <span data-ttu-id="36f12-209">接收者會在每個認可中，通告傳送者這個緩衝區中的剩餘空間量。</span><span class="sxs-lookup"><span data-stu-id="36f12-209">Receivers advertise to senders the amount of space that remains in this buffer in each of their acknowledgements.</span></span> <span data-ttu-id="36f12-210">傳送者可以使用此資訊，在每次接收者沒有剩餘的緩衝區空間時停止傳送新訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-210">Senders can use this information to stop sending new messages whenever the receiver has no buffer space left.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="36f12-211">擷取之屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="36f12-211">The type of property retrieved.</span></span></typeparam>
        <param name="context"><span data-ttu-id="36f12-212"><see cref="T:System.ServiceModel.Channels.BindingContext" />，其中包含擷取 <c>T</c> 類型通道時的必要資訊。</span><span class="sxs-lookup"><span data-stu-id="36f12-212">The <see cref="T:System.ServiceModel.Channels.BindingContext" /> that contains the information required to retrieve the channel of type <c>T</c>.</span></span></param>
        <summary><span data-ttu-id="36f12-213">從型別之繫結內容取得該指定型別的屬性。</span><span class="sxs-lookup"><span data-stu-id="36f12-213">Gets a property of the specified type from its binding context.</span></span></summary>
        <returns><span data-ttu-id="36f12-214">含有指定 <paramref name="T" /> 之型別 <paramref name="context" /> 的屬性，如果找不到型別 <see langword="null" /> 的屬性，則為 <paramref name="T" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-214">The property of type <paramref name="T" /> with the specified <paramref name="context" /> or <see langword="null" /> if no property of type <paramref name="T" /> is found.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InactivityTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan InactivityTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan InactivityTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property InactivityTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan InactivityTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-215">取得或設定服務在關閉之前維持在非作用狀態的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="36f12-215">Gets or sets an interval of time that a service remains inactive before closing.</span></span></summary>
        <value><span data-ttu-id="36f12-216"><see cref="T:System.TimeSpan" />，指定服務在關閉之前處於非作用中狀態的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="36f12-216">The <see cref="T:System.TimeSpan" /> that specifies the interval of time that a service remains inactive before closing.</span></span> <span data-ttu-id="36f12-217">預設值為 10 分鐘。</span><span class="sxs-lookup"><span data-stu-id="36f12-217">The default value is 10 minutes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-218">通道上的活動定義為收到應用程式或基礎結構訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-218">Activity on a channel is defined as receiving an application or infrastructure message.</span></span> <span data-ttu-id="36f12-219">無活動逾時參數會控制讓非作用中工作階段保持運作的最大時間量。</span><span class="sxs-lookup"><span data-stu-id="36f12-219">The inactivity timeout parameter controls the maximum amount of time to keep an inactive session alive.</span></span> <span data-ttu-id="36f12-220">如果超過 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> 時間間隔仍無任何活動，該工作階段便會由基礎結構和通道錯誤中止，</span><span class="sxs-lookup"><span data-stu-id="36f12-220">If more than <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> time interval passes with no activity, the session is aborted by the infrastructure and the channel faults.</span></span> <span data-ttu-id="36f12-221">此時可靠工作階段會單方面遭到終止。</span><span class="sxs-lookup"><span data-stu-id="36f12-221">The reliable session is torn down unilaterally.</span></span>  
  
 <span data-ttu-id="36f12-222">如果傳送應用程式沒有訊息要傳送，則可靠工作階段通常不會因無活動而發生錯誤；相反地，保持作用中的機制會無限期地讓工作階段保持在作用中。</span><span class="sxs-lookup"><span data-stu-id="36f12-222">If the sending application has no messages to send then the reliable session is normally not faulted because of inactivity; instead a keep-alive mechanism keeps the session active indefinitely.</span></span> <span data-ttu-id="36f12-223">請注意，在沒有傳送或接收應用程式訊息情況下，發送器可以獨立地中止可靠工作階段。</span><span class="sxs-lookup"><span data-stu-id="36f12-223">Note that the dispatcher can independently abort the reliable session if no application messages are sent or received.</span></span> <span data-ttu-id="36f12-224">因此，在沒有收到訊息或是傳送者發生失敗的網路情況下，無活動逾時通常就會過期。</span><span class="sxs-lookup"><span data-stu-id="36f12-224">Thus, the inactivity timeout typically expires if network conditions are such that no messages are received or if there is a failure on the sender.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="36f12-225">設定值為小於或等於零，或是大於 <see cref="F:System.Int32.MaxValue" /> 或 <see cref="F:System.TimeSpan.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-225">The value set is less than or equal to zero or greater than either <see cref="F:System.Int32.MaxValue" /> or <see cref="F:System.TimeSpan.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingChannels">
      <MemberSignature Language="C#" Value="public int MaxPendingChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingChannels { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-226">取得或設定可以在可靠工作階段期間擱置的最大通道數。</span><span class="sxs-lookup"><span data-stu-id="36f12-226">Gets or sets the largest number of channels that can be pending during the reliable session.</span></span></summary>
        <value><span data-ttu-id="36f12-227">可以擱置的最大通道數。</span><span class="sxs-lookup"><span data-stu-id="36f12-227">The largest number of channels that can be pending.</span></span> <span data-ttu-id="36f12-228">預設值為 4。</span><span class="sxs-lookup"><span data-stu-id="36f12-228">The default value is 4.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-229">通道在等待接受時會暫止。</span><span class="sxs-lookup"><span data-stu-id="36f12-229">Channels are pending when they are waiting to be accepted.</span></span> <span data-ttu-id="36f12-230">當到達該限制時並不會建立通道，同時進入擱置模式，直到這個數字降低 (即接受擱置通道)。</span><span class="sxs-lookup"><span data-stu-id="36f12-230">Once that limit is reached, no channels are created and put in pending mode until this number goes down (by accepting pending channels).</span></span> <span data-ttu-id="36f12-231">這個限制適用於每個接聽程式。</span><span class="sxs-lookup"><span data-stu-id="36f12-231">This is a limit for each listener.</span></span>  
  
 <span data-ttu-id="36f12-232">如果到達臨界值，而且遠端應用程式嘗試建立新的可靠工作階段，則要求會被拒絕，提示這個要求的開啟作業也會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="36f12-232">When the threshold is reached and a remote application tries to establish a new reliable session, the request is denied and the open operation that prompted this faults.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="36f12-233">設定值為小於或等於零，或是大於 16384。</span><span class="sxs-lookup"><span data-stu-id="36f12-233">The value set is less than or equal to zero or greater than 16384.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCount">
      <MemberSignature Language="C#" Value="public int MaxRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCount { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-234">取得或設定訊息在可靠工作階段期間嘗試傳輸的最大次數。</span><span class="sxs-lookup"><span data-stu-id="36f12-234">Gets or sets the maximum number of times that a message attempts to be transferred during the reliable session.</span></span></summary>
        <value><span data-ttu-id="36f12-235">訊息嘗試重新傳送的最大次數。</span><span class="sxs-lookup"><span data-stu-id="36f12-235">The maximum number of times that a message attempts to be re-sent.</span></span> <span data-ttu-id="36f12-236">最小值為 1，最大值為 <see cref="F:System.Int32.MaxValue" />，而預設值為 8。</span><span class="sxs-lookup"><span data-stu-id="36f12-236">The minimum value is 1; the maximum is <see cref="F:System.Int32.MaxValue" />; and the default value is 8.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-237">如果收件者已認可該處的訊息傳遞，則訊息會視為要傳輸的訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-237">A message is considered to be transferred if its delivery at the recipient has been acknowledged by the recipient.</span></span>  
  
 <span data-ttu-id="36f12-238">如果在特定一段時間內沒有收到已傳輸之訊息的認可，則基礎結構會自動重新傳輸該訊息。</span><span class="sxs-lookup"><span data-stu-id="36f12-238">If an acknowledgment has not been received within a certain amount of time for a message that has been transmitted, the infrastructure automatically retransmits the message.</span></span> <span data-ttu-id="36f12-239">基礎結構最多會嘗試傳送訊息 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> 次。</span><span class="sxs-lookup"><span data-stu-id="36f12-239">The infrastructure tries to send the message for, at most, a <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> number of times.</span></span> <span data-ttu-id="36f12-240">在到達此限制之前未收到認可會被視為嚴重的通訊失敗，並會引起通道錯誤事件。</span><span class="sxs-lookup"><span data-stu-id="36f12-240">Not receiving an acknowledgment before this limit is reached is considered a fatal communication failure and causes the channel faulted event to be raised.</span></span>  
  
 <span data-ttu-id="36f12-241">基礎結構會使用指數倒退演算法，根據計算出來的平均來回時間決定何時重新傳輸。</span><span class="sxs-lookup"><span data-stu-id="36f12-241">The infrastructure uses an exponential back-off algorithm to determine when to retransmit, based on a computed average round-trip time.</span></span> <span data-ttu-id="36f12-242">初始重試時間的計算根據是所測量之建立工作階段的來回時間。</span><span class="sxs-lookup"><span data-stu-id="36f12-242">The initial retry time is computed based on the measured roundtrip time of establishing the session.</span></span> <span data-ttu-id="36f12-243">重新傳輸演算法會讓延遲時間隨著每次嘗試而加倍，造成第一次重新傳輸嘗試到最後一次重新傳輸嘗試之間會經過約 8.5 分鐘。</span><span class="sxs-lookup"><span data-stu-id="36f12-243">The retransmission algorithm doubles the delay with every attempt, which results in approximately 8.5 minutes passing between the first transmission attempt and the last retransmission attempt.</span></span> <span data-ttu-id="36f12-244">第一次嘗試重新傳輸的時間會根據計算出來的來回時間調整，這些嘗試所花費的時間也會因此而有所不同。</span><span class="sxs-lookup"><span data-stu-id="36f12-244">The time for the first retransmission attempt is adjusted according to the calculated round-trip time and the resulting stretch of time that those attempts take varies accordingly.</span></span> <span data-ttu-id="36f12-245">如此便可讓重新傳輸時間透過動態的方式適應多變的網路狀況。</span><span class="sxs-lookup"><span data-stu-id="36f12-245">This allows the retransmission time to dynamically adapt to varying network conditions.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="36f12-246">設定的值小於或等於零。</span><span class="sxs-lookup"><span data-stu-id="36f12-246">The value set is less than or equal to zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxTransferWindowSize">
      <MemberSignature Language="C#" Value="public int MaxTransferWindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransferWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransferWindowSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransferWindowSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-247">取得或設定可以存在傳送緩衝區或接收緩衝區中的最大訊息數。</span><span class="sxs-lookup"><span data-stu-id="36f12-247">Gets or sets the largest number of messages that can exist in either the send buffer or the receive buffer.</span></span></summary>
        <value><span data-ttu-id="36f12-248">可以緩衝處理的最大訊息數。</span><span class="sxs-lookup"><span data-stu-id="36f12-248">The largest number of messages that can be buffered.</span></span> <span data-ttu-id="36f12-249">最小值為 1，最大值為 4096，而預設值為 32。</span><span class="sxs-lookup"><span data-stu-id="36f12-249">The minimum value is 1; the maximum value is 4096; and the default value is 32.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-250"><xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> 屬性的值可以同時設定於傳送者或接收者。</span><span class="sxs-lookup"><span data-stu-id="36f12-250">The value of the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> property can be set on both the sender and the receiver.</span></span> <span data-ttu-id="36f12-251">這個值會包含在繫結原則的 WSDL，因此如果您使用[ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)建構用戶端，並具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="36f12-251">This value is included in the binding policy of the WSDL, so if you use the [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to construct your client, it has the same value.</span></span> <span data-ttu-id="36f12-252">否則，這個值就是您在用戶端上設定的任意值。</span><span class="sxs-lookup"><span data-stu-id="36f12-252">Otherwise this value is whatever you set it to be on the client.</span></span>  
  
 <span data-ttu-id="36f12-253">當傳送者到達這個限制時，其他的傳送呼叫就會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="36f12-253">When this limit is reached on the sender, additional calls to send are blocked.</span></span> <span data-ttu-id="36f12-254">當接收者到達這個限制時，到達基礎通道的新訊息將不會被接受。</span><span class="sxs-lookup"><span data-stu-id="36f12-254">When this limit is reached on the receiver, new messages that arrive on the underlying channel are not accepted.</span></span>  
  
 <span data-ttu-id="36f12-255">可靠工作階段會使用視窗通訊協定來協助改善網路的使用。</span><span class="sxs-lookup"><span data-stu-id="36f12-255">A reliable session uses a windowing protocol to help improve network utilization.</span></span> <span data-ttu-id="36f12-256">所需要的緩衝量是直接衍生自傳輸視窗的大小。</span><span class="sxs-lookup"><span data-stu-id="36f12-256">The amount of buffering required is directly derived from the size of the transmission window.</span></span> <span data-ttu-id="36f12-257">當調整這個值時，請注意頻寬和延遲時間與最佳傳輸視窗有直接的關聯。</span><span class="sxs-lookup"><span data-stu-id="36f12-257">When tuning this value, note that the optimal transmission window is related to the bandwidth and the latency in a straight-forward way.</span></span> <span data-ttu-id="36f12-258">理想的視窗大小上限為頻寬乘以延遲時間。</span><span class="sxs-lookup"><span data-stu-id="36f12-258">The ideal maximum window size is the bandwidth times the latency.</span></span> <span data-ttu-id="36f12-259">較小的任何值會產生不到 100% 的網路使用量，而較大的任何值則只是浪費空間。</span><span class="sxs-lookup"><span data-stu-id="36f12-259">Anything smaller yields less than 100% network utilization; anything larger is just wasted space.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="36f12-260">設定值小於或等於 1，或是大於 4096。</span><span class="sxs-lookup"><span data-stu-id="36f12-260">The value set is less than or equal to one or greater than 4096.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Ordered">
      <MemberSignature Language="C#" Value="public bool Ordered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Ordered" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberSignature Language="VB.NET" Value="Public Property Ordered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Ordered { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-261">取得或設定值，這個值會指出訊息傳遞是否必須保留訊息傳送時的順序。</span><span class="sxs-lookup"><span data-stu-id="36f12-261">Gets or sets a value that indicates whether message delivery must preserve the order in which messages are sent.</span></span></summary>
        <value>
          <span data-ttu-id="36f12-262">如果訊息必須按照其傳送的順序傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-262"><see langword="true" /> if messages must be delivered in the order in which they are sent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="36f12-263">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="36f12-263">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-264">若要讓訊息依順序分派，您必須同時將 <xref:System.ServiceModel.ConcurrencyMode> 設定為 <xref:System.ServiceModel.ConcurrencyMode.Single>。</span><span class="sxs-lookup"><span data-stu-id="36f12-264">To get messages dispatched in order, you also must set the <xref:System.ServiceModel.ConcurrencyMode> to <xref:System.ServiceModel.ConcurrencyMode.Single>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableMessagingVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ReliableMessagingVersion As ReliableMessagingVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReliableMessagingVersion ^ ReliableMessagingVersion { System::ServiceModel::ReliableMessagingVersion ^ get(); void set(System::ServiceModel::ReliableMessagingVersion ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReliableMessagingVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36f12-265">取得或設定繫結項目指定的 WS-ReliableMessaging 的版本。</span><span class="sxs-lookup"><span data-stu-id="36f12-265">Gets or sets the version of WS-ReliableMessaging specified by the binding element.</span></span></summary>
        <value><span data-ttu-id="36f12-266">自 <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> 衍生的執行個體，代表組態項目使用的 WS-ReliableMessaging 通訊協定版本。</span><span class="sxs-lookup"><span data-stu-id="36f12-266">An instance derived from <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> that represents the version of the WS-ReliableMessaging protocol used by the configuration element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36f12-267">[!INCLUDE[indigo1](~/includes/indigo1-md.md)] 目前支援兩種版本的 WS-ReliableMessaging 通訊協定：WS-ReliableMessaging1.1 和 WS-ReliableMessagingFebruary2005。</span><span class="sxs-lookup"><span data-stu-id="36f12-267">There are currently two versions of the WS-ReliableMessaging protocol supported by [!INCLUDE[indigo1](~/includes/indigo1-md.md)]: WS-ReliableMessaging1.1 and WS-ReliableMessagingFebruary2005.</span></span> <span data-ttu-id="36f12-268">預設的版本是 WS-ReliableMessagingFebruary2005。</span><span class="sxs-lookup"><span data-stu-id="36f12-268">The default version is WS-ReliableMessagingFebruary2005.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter"><span data-ttu-id="36f12-269"><see cref="T:System.ServiceModel.Description.MetadataExporter" />，它會將可靠工作階段繫結項目中的繫結資訊匯出至 WSDL 項目。</span><span class="sxs-lookup"><span data-stu-id="36f12-269">The <see cref="T:System.ServiceModel.Description.MetadataExporter" /> that exports the binding information in the reliable session binding element to the WSDL elements.</span></span></param>
        <param name="context"><span data-ttu-id="36f12-270"><see cref="T:System.ServiceModel.Description.PolicyConversionContext" />，它會提供從匯出的 WSDL 項目對應到端點描述。</span><span class="sxs-lookup"><span data-stu-id="36f12-270">The <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> that provides the mapping from exported WSDL elements to the endpoint description.</span></span></param>
        <summary><span data-ttu-id="36f12-271">將可靠工作階段繫結項目中包含的資訊對應至 WSDL 項目，該項目可讓遠端端點使用可靠工作階段來存取服務。</span><span class="sxs-lookup"><span data-stu-id="36f12-271">Maps the information contained in the reliable session binding element into the WSDL elements that enable a remote endpoint to access the service with a reliable session.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>